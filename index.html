<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aegis DM Toolkit</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        // ADDED: GoogleAuthProvider, signInWithPopup, signOut
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, deleteDoc, getDoc, collection, query, onSnapshot, setLogLevel, addDoc, updateDoc, orderBy, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Expose necessary Firestore functions globally
        window.doc = doc;
        window.setDoc = setDoc;
        window.deleteDoc = deleteDoc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;
        window.addDoc = addDoc;
        window.getDoc = getDoc; 
        window.updateDoc = updateDoc; 
        window.orderBy = orderBy; 
        window.writeBatch = writeBatch; 

        // Expose Auth functions
        window.GoogleAuthProvider = GoogleAuthProvider;
        window.signInWithPopup = signInWithPopup;
        window.signOut = signOut;

        // Global Firebase variables for the app to use
        window.db = null;
        window.auth = null;
        window.userId = null;
        window.isAuthReady = false;

        // --- NETLIFY / PUBLIC DEPLOYMENT CONFIGURATION ---
        const manualFirebaseConfig = {
            apiKey: "AIzaSyB6lyGYJzk70t1OJvzBn5uyJN_k2_5NKYg",
            authDomain: "aegisdmtoolkit.firebaseapp.com",
            projectId: "aegisdmtoolkit",
            storageBucket: "aegisdmtoolkit.firebasestorage.app",
            messagingSenderId: "654767294266",
            appId: "1:654767294266:web:fbee20be7d458fb7d6f203"
        };
        // --------------------------------------------------

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const envFirebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Determine which config to use
        const isManualConfig = (manualFirebaseConfig.apiKey && manualFirebaseConfig.apiKey !== "PASTE_YOUR_API_KEY_HERE");
        const firebaseConfig = isManualConfig ? manualFirebaseConfig : envFirebaseConfig;

        if (firebaseConfig && Object.keys(firebaseConfig).length > 0) {
            setLogLevel('debug'); 
            const app = initializeApp(firebaseConfig);
            window.db = getFirestore(app);
            window.auth = getAuth(app);
            
            // Authenticate
            onAuthStateChanged(window.auth, async (user) => {
                if (!user) {
                    // Logic Fix: 
                    // If we are using a manual config (e.g. your own Firebase project), 
                    // the 'initialAuthToken' provided by the Canvas environment will NOT match.
                    // So we should only try custom token auth if we are NOT using manual config.
                    if (initialAuthToken && !isManualConfig) {
                        try {
                            await signInWithCustomToken(window.auth, initialAuthToken);
                        } catch (error) {
                            console.warn("Custom token auth failed (likely mismatch), falling back to anonymous:", error);
                            await signInAnonymously(window.auth);
                        }
                    } else {
                        // Default to anonymous for manual configs or if no token exists
                        try {
                            await signInAnonymously(window.auth);
                        } catch (error) {
                            console.error("Anonymous login failed:", error);
                        }
                    }
                } else {
                    // Force token refresh to prevent stale connection issues
                    try {
                        await user.getIdToken(true); 
                    } catch (tokenError) {
                        console.error("Error refreshing ID token:", tokenError);
                    }

                    window.userId = user.uid;
                    window.isAuthReady = true;
                    
                    // --- UPDATE UI FOR LOGIN STATE ---
                    updateLoginUI(user);

                    console.log("Auth ready, setting up listeners...");
                    if (window.setupNotesListener) window.setupNotesListener();
                    if (window.setupCombatDataListeners) window.setupCombatDataListeners();
                    if (window.setupStatblocksListener) window.setupStatblocksListener();
                }
            });
        } else {
            console.error("Firebase configuration not found.");
        }

        function updateLoginUI(user) {
            const loginBtn = document.getElementById('login-btn');
            const userProfile = document.getElementById('user-profile');
            const userAvatar = document.getElementById('user-avatar');
            const userName = document.getElementById('user-name');

            if (user.isAnonymous) {
                // Show Login Button
                if(loginBtn) loginBtn.classList.remove('hidden');
                if(userProfile) userProfile.classList.add('hidden');
            } else {
                // Show User Profile
                if(loginBtn) loginBtn.classList.add('hidden');
                if(userProfile) userProfile.classList.remove('hidden');
                if(userAvatar) userAvatar.src = user.photoURL || 'https://via.placeholder.com/32';
                if(userName) userName.textContent = user.displayName || 'Adventurer';
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #f8fafc; }
        .tab-button.active { border-bottom: 3px solid #6366f1; color: #c7d2fe; }
        .sub-tab-button.active { border-bottom: 2px solid #34d399; color: #34d399; }
        .card { background-color: #1e293b; border: 1px solid #334155; }
        .input-style { background-color: #334155; border: 1px solid #475569; color: #f8fafc; }
        .glow-shadow { box-shadow: 0 0 10px rgba(99, 102, 241, 0.5); }
        .scrollable-content { max-height: 60vh; overflow-y: auto; }
        /* Scrollbar styles for dark mode aesthetics */
        .scrollable-content::-webkit-scrollbar { width: 8px; }
        .scrollable-content::-webkit-scrollbar-track { background: #1e293b; }
        .scrollable-content::-webkit-scrollbar-thumb { background-color: #475569; border-radius: 20px; border: 2px solid #1e293b; }
        .loading-spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid #fff; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Collapsible Styles */
        .collapsible-header { cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 10px; background-color: #334155; border-radius: 8px; }
        .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; padding: 0 10px; }
        .collapsible-content.expanded { max-height: 1000px; padding: 10px; }
        .arrow-icon { transition: transform 0.3s ease; }
        .expanded .arrow-icon { transform: rotate(90deg); }
        /* Soundboard Button Styles */
        .sound-btn { transition: all 0.1s ease; }
        .sound-btn:active { transform: scale(0.95); }
        /* Active state for Ambience Toggle */
        .sound-btn.active-loop { border-color: #34d399; background-color: #059669; box-shadow: 0 0 15px #34d399; animation: pulse-green 2s infinite; }
        @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(52, 211, 153, 0); } 100% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0); } }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="max-w-4xl mx-auto">
        
        <!-- NEW: Top Header with Login -->
        <div class="flex justify-between items-center mb-6 bg-gray-800 p-3 rounded-lg border border-gray-700 shadow-lg">
            <h1 class="text-2xl font-bold text-indigo-400 flex items-center gap-2">
                <span>üõ°Ô∏è</span> Aegis DM Toolkit
            </h1>
            
            <!-- Login / User Section -->
            <div>
                <!-- Login Button (Hidden by default, shown via JS if anonymous) -->
                <button id="login-btn" onclick="loginWithGoogle()" class="hidden bg-white text-gray-900 hover:bg-gray-200 font-bold py-2 px-4 rounded-lg text-sm flex items-center gap-2 transition duration-200">
                    <svg class="w-4 h-4" viewBox="0 0 24 24" fill="currentColor"><path d="M12.545,10.239v3.821h5.445c-0.712,2.315-2.647,3.972-5.445,3.972c-3.332,0-6.033-2.701-6.033-6.032s2.701-6.032,6.033-6.032c1.498,0,2.866,0.549,3.921,1.453l2.814-2.814C17.503,2.988,15.139,2,12.545,2C7.021,2,2.543,6.477,2.543,12s4.478,10,10.002,10c8.396,0,10.249-7.85,9.426-11.748L12.545,10.239z"/></svg>
                    Sign in with Google
                </button>

                <!-- User Profile (Hidden by default, shown via JS if logged in) -->
                <div id="user-profile" class="hidden flex items-center gap-3">
                    <div class="text-right hidden sm:block">
                        <div id="user-name" class="text-sm font-semibold text-white">Adventurer</div>
                        <div class="text-xs text-green-400">Online & Saving</div>
                    </div>
                    <img id="user-avatar" src="" alt="User" class="w-9 h-9 rounded-full border-2 border-indigo-500">
                    <button onclick="logoutUser()" class="bg-red-900/50 hover:bg-red-800 text-red-200 p-2 rounded-lg text-xs border border-red-800 transition duration-200" title="Sign Out">
                        Sign Out
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Tab Navigation -->
        <div class="flex border-b border-gray-600 mb-6 overflow-x-auto">
            <button class="tab-button p-3 flex-1 text-sm font-semibold transition duration-300 active min-w-[100px]" onclick="switchTab('improv')">
                üîÆ Prep
            </button>
            <button class="tab-button p-3 flex-1 text-sm font-semibold text-gray-400 transition duration-300 min-w-[100px]" onclick="switchTab('combat')">
                ‚öîÔ∏è Combat
            </button>
            <button class="tab-button p-3 flex-1 text-sm font-semibold text-gray-400 transition duration-300 min-w-[100px]" onclick="switchTab('statblocks')">
                üëπ Stats
            </button>
            <!-- NEW MONSTERS TAB BUTTON -->
            <button class="tab-button p-3 flex-1 text-sm font-semibold text-gray-400 transition duration-300 min-w-[100px]" onclick="switchTab('monsters')">
                üê≤ Monsters
            </button>
            <!-- NEW LOOT TAB BUTTON -->
            <button class="tab-button p-3 flex-1 text-sm font-semibold text-gray-400 transition duration-300 min-w-[100px]" onclick="switchTab('loot')">
                üí∞ Loot
            </button>
            <!-- NEW SOUNDBOARD TAB BUTTON -->
            <button class="tab-button p-3 flex-1 text-sm font-semibold text-gray-400 transition duration-300 min-w-[100px]" onclick="switchTab('soundboard')">
                üîä Sound
            </button>
            <button class="tab-button p-3 flex-1 text-sm font-semibold text-gray-400 transition duration-300 min-w-[100px]" onclick="switchTab('notes')">
                üìú Notes
            </button>
        </div>

        <!-- Content Area -->
        <div id="content-area">
            <!-- 1. Prep & Improv Engine (Gemini API) -->
            <div id="improv" class="tab-content">
                
                <!-- NEW: AI Configuration Card (User Input for API Key) -->
                <div class="card p-4 rounded-lg shadow-xl mb-6 border border-indigo-500/30">
                    <h2 class="text-xl font-semibold mb-2 text-indigo-300">üîë AI Configuration</h2>
                    <p class="text-xs text-gray-400 mb-3">Enter your Google Gemini API Key to enable AI generation features. Your key is saved locally in your browser.</p>
                    <div class="flex gap-2">
                        <input type="password" id="user-api-key" placeholder="Paste API Key (AIza...)" class="flex-1 p-2 rounded-lg input-style text-sm">
                        <button onclick="saveApiKey()" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg text-sm transition duration-200">Save</button>
                    </div>
                    <p id="api-key-status" class="mt-2 text-xs text-gray-500">Status: No key saved.</p>
                </div>

                <!-- Structured Combat NPC Generator -->
                <div class="card p-4 rounded-lg shadow-xl mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-green-300">Structured Combat NPC Stats</h2>
                    <p class="text-sm text-gray-400 mb-4">Generate immediate, initiative-ready stats based on a target level/CR.</p>
                    
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="npc-level" class="block text-xs font-medium text-gray-400 mb-1">Level or CR (e.g., 5 or 1/2)</label>
                            <input type="text" id="npc-level" value="3" placeholder="Level/CR"
                                class="w-full p-2 rounded-lg input-style transition text-sm">
                        </div>
                        <div>
                            <label for="npc-type" class="block text-xs font-medium text-gray-400 mb-1">NPC Type (e.g., Goblin Shaman)</label>
                            <input type="text" id="npc-type" value="Shadow Rogue" placeholder="Type or Vibe"
                                class="w-full p-2 rounded-lg input-style transition text-sm">
                        </div>
                    </div>

                    <button onclick="generateCombatNpc()" id="generate-combat-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded-lg transition duration-300 flex items-center justify-center">
                        <span id="generate-combat-text">Generate Combat Stats</span>
                        <div id="combat-loading-spinner" class="loading-spinner ml-2 hidden"></div>
                    </button>
                    <p id="combat-status-message" class="mt-2 text-sm text-center text-red-400 hidden"></p>
                </div>


                <!-- Free-Form Creative Generator (Original) -->
                <div class="card p-4 rounded-lg shadow-xl mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-300">Creative Lore & Backstory</h2>
                    <p class="text-sm text-gray-400 mb-4">Need an NPC's backstory, a quick location, or lore?</p>
                    <textarea id="improv-prompt" rows="3" class="w-full p-3 rounded-lg input-style resize-none focus:ring-2 focus:ring-indigo-500" placeholder="e.g., A grumpy female blacksmith who secretly loves high fantasy romance novels and has a quest for a rare flower."></textarea>
                    <button onclick="generateCreativeIdea()" id="generate-button" class="mt-4 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 rounded-lg transition duration-300 flex items-center justify-center">
                        <span id="generate-text">Generate Idea</span>
                        <div id="creative-loading-spinner" class="loading-spinner ml-2 hidden"></div>
                    </button>
                </div>

                <!-- NEW: Settlement Generator -->
                <div class="card p-4 rounded-lg shadow-xl mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-teal-300">Settlement Generator</h2>
                    <p class="text-sm text-gray-400 mb-4">Quickly generate a city, town, or village with key locations, NPCs, and quest hooks.</p>
                    
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="settlement-type" class="block text-xs font-medium text-gray-400 mb-1">Settlement Type</label>
                            <select id="settlement-type" class="w-full p-2 rounded-lg input-style transition text-sm">
                                <option value="Village" selected>Village</option>
                                <option value="Town">Town</option>
                                <option value="City">City</option>
                            </select>
                        </div>
                        <div>
                            <label for="settlement-vibe" class="block text-xs font-medium text-gray-400 mb-1">Vibe/Description</label>
                            <input type="text" id="settlement-vibe" value="haunted fishing village" placeholder="e.g., 'desert trade post'"
                                class="w-full p-2 rounded-lg input-style transition text-sm">
                        </div>
                    </div>

                    <button onclick="generateSettlement()" id="generate-settlement-button" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 rounded-lg transition duration-300 flex items-center justify-center">
                        <span id="generate-settlement-text">Generate Settlement</span>
                        <div id="settlement-loading-spinner" class="loading-spinner ml-2 hidden"></div>
                    </button>
                </div>


                <div class="card p-4 rounded-lg shadow-xl">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-300">Generated Idea</h2>
                    
                    <!-- NEW: Image Output Area -->
                    <div id="ai-image-output" class="mb-4 hidden rounded-lg overflow-hidden shadow-lg">
                        <img id="generated-image" src="" alt="Generated Settlement Image" class="w-full h-auto object-cover bg-gray-700/30 min-h-[150px]">
                        <p id="image-loading-status" class="text-center text-gray-400 p-3 bg-gray-800"></p>
                    </div>

                    <!-- Single output div for both modes -->
                    <div id="ai-output" class="whitespace-pre-wrap min-h-[100px] bg-gray-700/30 p-3 rounded-lg text-gray-300">
                        Results will appear here.
                    </div>
                    <!-- Status message for saving generated NPC combat stats -->
                    <p id="npc-save-status" class="mt-2 text-sm text-center hidden"></p>
                    
                    <!-- NEW: Save Options for Creative Content -->
                    <div id="save-options-creative" class="mt-4 hidden">
                        <p class="text-sm text-center text-gray-400 mb-2">Save generated content to the Rulings & Notes tab:</p>
                        <div class="grid grid-cols-3 gap-2">
                            <button onclick="saveGeneratedContent('prepNotes')" class="save-notes-btn bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 rounded-lg transition duration-300 text-xs">Save to Notes</button>
                            <button onclick="saveGeneratedContent('enemyNotes')" class="save-notes-btn bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 rounded-lg transition duration-300 text-xs">Save to Enemies</button>
                            <button onclick="saveGeneratedContent('npcNotes')" class="save-notes-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg transition duration-300 text-xs">Save to NPCs</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 2. Combat Tracker -->
            <div id="combat" class="tab-content hidden">
                <div class="card p-4 rounded-lg shadow-xl">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-300">Initiative & Monster Tracker</h2>
                    <!-- Added Connectivity Status Indicator -->
                    <div class="flex justify-between items-center mb-2">
                        <p class="text-sm text-gray-400">Keeps combat flowing smoothly.</p>
                        <span id="db-status" class="text-xs px-2 py-1 rounded bg-gray-700 text-gray-400">Connecting...</span>
                    </div>

                    <!-- Responsive Input Group -->
                    <div class="flex flex-wrap gap-2 mb-4">
                        <input id="combatant-name" type="text" placeholder="Name" class="flex-1 min-w-[100px] p-2 rounded-lg input-style" />
                        <!-- Initiative can be a fixed score or a modifier -->
                        <input id="combatant-init" type="number" placeholder="Init Score/Mod" class="w-24 p-2 rounded-lg input-style text-center text-sm" />
                        <!-- AC Input -->
                        <input id="combatant-ac" type="number" placeholder="AC" class="w-16 p-2 rounded-lg input-style text-center text-sm" />
                        <input id="combatant-hp" type="number" placeholder="HP" class="w-16 p-2 rounded-lg input-style text-center text-sm" />
                        <button onclick="addCombatant()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold px-3 py-2 rounded-lg transition duration-300 text-sm">Add</button>
                    </div>

                    <!-- Dice Roller Section -->
                    <div class="card p-4 rounded-lg shadow-inner mb-4 bg-gray-800/50">
                        <h3 class="text-md font-semibold mb-2 text-indigo-400">Initiative Dice Roller (D20)</h3>
                        <div class="flex items-center space-x-2">
                            <button onclick="rollD20()" id="d20-roll-button" class="w-1/3 bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded-lg transition duration-300 text-sm flex items-center justify-center">
                                Roll D20
                            </button>
                            <div id="last-roll-display" class="w-1/3 text-4xl font-extrabold text-center text-yellow-400 border-2 border-yellow-400 p-2 rounded-lg bg-gray-900/50 select-none">
                                ?
                            </div>
                            <select id="combatant-selector" class="w-1/3 p-2 rounded-lg input-style text-sm">
                                <option value="" disabled selected>Select Target</option>
                            </select>
                        </div>
                        <button onclick="assignInitiativeRoll()" id="assign-roll-button" class="mt-2 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg transition duration-300 text-sm disabled:opacity-50" disabled>
                            Assign Roll to Selected + Stored Modifier
                        </button>
                        <p class="text-xs text-gray-400 mt-2 text-center">
                            *The combatant's **stored** Initiative Modifier is automatically used for the final score calculation.
                        </p>
                    </div>


                    <div class="flex justify-between items-center mb-4">
                        <button onclick="sortInitiative()" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg transition duration-300 text-sm">Sort Initiative</button>
                        <button onclick="nextTurn()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-lg transition duration-300 text-sm">Next Turn &raquo;</button>
                        <button onclick="clearCombat()" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-lg transition duration-300 text-sm">Clear All</button>
                    </div>
                    
                    <div id="initiative-list" class="scrollable-content space-y-2">
                        <!-- Combatant list will be dynamically inserted here -->
                        <p class="text-center text-gray-500 pt-8">Add your players and monsters to start tracking combat!</p>
                    </div>
                </div>
            </div>

            <!-- 3. Statblocks Tab -->
            <div id="statblocks" class="tab-content hidden">
                <div class="card p-4 rounded-lg shadow-xl mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-300">Save NPC & Monster Statblocks</h2>
                    <p class="text-sm text-gray-400 mb-4">Define common enemies and allies for quick reference and future combat imports.</p>
                    
                    <div class="grid grid-cols-2 gap-2 mb-4">
                        <input id="stat-name" type="text" placeholder="Name (e.g., Orc Grunt)" class="col-span-2 p-2 rounded-lg input-style" />
                        <input id="stat-hp" type="number" placeholder="HP (e.g., 15)" class="p-2 rounded-lg input-style text-center text-sm" />
                        <input id="stat-ac" type="number" placeholder="AC (e.g., 13)" class="p-2 rounded-lg input-style text-center text-sm" />
                        <input id="stat-tohit" type="number" placeholder="To Hit Mod (e.g., +4)" class="p-2 rounded-lg input-style text-center text-sm" />
                        <input id="stat-init-mod" type="number" placeholder="Init Mod (e.g., +1)" class="p-2 rounded-lg input-style text-center text-sm" />
                        <input id="stat-dmg" type="text" placeholder="Attack DMG (e.g., 1d8+2)" class="col-span-2 p-2 rounded-lg input-style" />
                    </div>

                    <button onclick="saveStatblock()" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 rounded-lg transition duration-300">
                        Save Statblock
                    </button>
                    <p id="statblock-status" class="mt-2 text-sm text-center text-gray-400"></p>
                </div>

                <!-- NEW DICE ROLLER CARD -->
                <div class="card p-4 rounded-lg shadow-xl mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-teal-300">Quick Dice Roller</h2>
                    <div class="flex flex-wrap items-center gap-2 mb-4">
                        <input id="dice-num" type="number" value="1" min="1" class="w-16 p-2 rounded-lg input-style text-center text-sm" aria-label="Number of Dice" />
                        <span class="text-lg font-semibold text-gray-400">d</span>
                        <select id="dice-type" class="p-2 rounded-lg input-style text-sm" aria-label="Dice Type">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="20" selected>20</option>
                            <option value="100">100</option>
                        </select>
                        <span class="text-lg font-semibold text-gray-400">+</span>
                        <input id="dice-mod" type="number" value="0" class="w-16 p-2 rounded-lg input-style text-center text-sm" aria-label="Modifier" />
                    </div>
                    <button onclick="rollCustomDice()" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 rounded-lg transition duration-300">
                        Roll Dice
                    </button>
                    <div id="dice-roll-result" class="mt-4 text-center text-xl font-bold text-yellow-300 bg-gray-700/50 p-3 rounded-lg min-h-[50px] flex items-center justify-center">
                        Result will appear here
                    </div>
                    <p id="dice-roll-details" class="mt-2 text-center text-sm text-gray-400"></p>
                </div>
                <!-- END NEW DICE ROLLER CARD -->

                <div class="card p-4 rounded-lg shadow-xl">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-300">Saved Statblocks</h2>
                    <div id="statblocks-list" class="scrollable-content space-y-2">
                         <p class="text-center text-gray-500 pt-8">Your saved NPCs and monsters will appear here.</p>
                    </div>
                </div>
            </div>

            <!-- 4. NEW Monsters Tab -->
            <div id="monsters" class="tab-content hidden">
                <div class="card p-4 rounded-lg shadow-xl mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-green-300">Full Monster Stat Block Generator</h2>
                    <p class="text-sm text-gray-400 mb-4">Generate a complete D&D 5e-style monster stat block using AI.</p>
                    
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="monster-name" class="block text-xs font-medium text-gray-400 mb-1">Monster Name (e.g., "Goblin Boss")</label>
                            <input type="text" id="monster-name" value="Cave Troll" placeholder="Monster Name"
                                class="w-full p-2 rounded-lg input-style transition text-sm">
                        </div>
                        <div>
                            <label for="monster-cr" class="block text-xs font-medium text-gray-400 mb-1">Challenge Rating (e.g., "5" or "1/4")</label>
                            <input type="text" id="monster-cr" value="4" placeholder="CR"
                                class="w-full p-2 rounded-lg input-style transition text-sm">
                        </div>
                    </div>

                    <button onclick="generateMonsterStatblock()" id="generate-monster-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded-lg transition duration-300 flex items-center justify-center">
                        <span id="generate-monster-text">Generate Monster</span>
                        <div id="monster-loading-spinner" class="loading-spinner ml-2 hidden"></div>
                    </button>
                    <p id="monster-status-message" class="mt-2 text-sm text-center text-red-400 hidden"></p>
                </div>

                <div class="card p-4 rounded-lg shadow-xl">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-300">Generated Stat Block</h2>
                    <!-- Output div for the monster stat block -->
                    <div id="monster-output" class="min-h-[100px] bg-gray-700/30 p-3 rounded-lg text-gray-300">
                        Monster stat block will appear here.
                    </div>
                    <!-- Status message for saving -->
                    <p id="monster-save-status" class="mt-2 text-sm text-center hidden"></p>
                    
                    <!-- Save Options for Monster -->
                    <div id="save-options-monster" class="mt-4 hidden">
                        <p class="text-sm text-center text-gray-400 mb-2">Save generated monster:</p>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="addMonsterToStatblocks()" class="save-monster-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 rounded-lg transition duration-300 text-xs">Save to Statblocks (Combat)</button>
                            <button onclick="saveMonsterToNotes()" class="save-monster-btn bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 rounded-lg transition duration-300 text-xs">Save to Enemy Notes (Full)</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- NEW: Loot Generator Tab -->
            <div id="loot" class="tab-content hidden">
                <div class="card p-4 rounded-lg shadow-xl mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-yellow-300">AI Loot Generator</h2>
                    <p class="text-sm text-gray-400 mb-4">Generate balanced loot drops for individual enemies or entire treasure hoards.</p>
                    
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="loot-level" class="block text-xs font-medium text-gray-400 mb-1">Party Level or CR</label>
                            <input type="text" id="loot-level" value="3" placeholder="Level/CR"
                                class="w-full p-2 rounded-lg input-style transition text-sm">
                        </div>
                        <div>
                            <label for="loot-type" class="block text-xs font-medium text-gray-400 mb-1">Loot Type</label>
                            <select id="loot-type" class="w-full p-2 rounded-lg input-style transition text-sm">
                                <option value="Individual">Individual Pockets</option>
                                <option value="Hoard">Boss Hoard / Chest</option>
                                <option value="Shop Inventory">Shop Inventory</option>
                            </select>
                        </div>
                    </div>

                    <button onclick="generateLoot()" id="generate-loot-button" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 rounded-lg transition duration-300 flex items-center justify-center">
                        <span id="generate-loot-text">Generate Loot</span>
                        <div id="loot-loading-spinner" class="loading-spinner ml-2 hidden"></div>
                    </button>
                </div>

                <div class="card p-4 rounded-lg shadow-xl">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-300">Loot Results</h2>
                    <div id="loot-output" class="whitespace-pre-wrap min-h-[100px] bg-gray-700/30 p-3 rounded-lg text-gray-300">
                        Loot drops will appear here.
                    </div>
                    <!-- Save Option for Loot -->
                    <button onclick="saveGeneratedContent('prepNotes')" class="mt-4 w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 rounded-lg transition duration-300 text-sm">
                        Save to Notes
                    </button>
                </div>
            </div>

            <!-- NEW: Soundboard Tab -->
            <div id="soundboard" class="tab-content hidden">
                <div class="card p-4 rounded-lg shadow-xl mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-pink-300">Synth Soundboard</h2>
                    <p class="text-sm text-gray-400 mb-4">Instant sound effects and looping ambiences synthesized in your browser. No external files required.</p>
                    
                    <!-- One-Shot SFX -->
                    <h3 class="text-sm font-semibold text-gray-400 mb-2 uppercase tracking-wider">One-Shot Effects</h3>
                    <div class="grid grid-cols-2 sm:grid-cols-3 gap-4 mb-6">
                        <!-- Success Sounds -->
                        <button onclick="playTone('success')" class="sound-btn bg-green-600 hover:bg-green-500 text-white font-bold py-4 rounded-lg shadow-lg border-b-4 border-green-800 flex flex-col items-center justify-center">
                            <span class="text-2xl mb-1">‚ú®</span>
                            <span class="text-xs">Success</span>
                        </button>
                        <button onclick="playTone('critical')" class="sound-btn bg-green-700 hover:bg-green-600 text-white font-bold py-4 rounded-lg shadow-lg border-b-4 border-green-900 flex flex-col items-center justify-center">
                            <span class="text-2xl mb-1">üéâ</span>
                            <span class="text-xs">Crit Success</span>
                        </button>
                        
                        <!-- Failure Sounds -->
                        <button onclick="playTone('fail')" class="sound-btn bg-red-600 hover:bg-red-500 text-white font-bold py-4 rounded-lg shadow-lg border-b-4 border-red-800 flex flex-col items-center justify-center">
                            <span class="text-2xl mb-1">‚ùå</span>
                            <span class="text-xs">Fail</span>
                        </button>
                        
                        <!-- Combat Sounds -->
                        <button onclick="playTone('combat_start')" class="sound-btn bg-orange-600 hover:bg-orange-500 text-white font-bold py-4 rounded-lg shadow-lg border-b-4 border-orange-800 flex flex-col items-center justify-center">
                            <span class="text-2xl mb-1">‚öîÔ∏è</span>
                            <span class="text-xs">Combat!</span>
                        </button>
                        <button onclick="playTone('spell')" class="sound-btn bg-purple-600 hover:bg-purple-500 text-white font-bold py-4 rounded-lg shadow-lg border-b-4 border-purple-800 flex flex-col items-center justify-center">
                            <span class="text-2xl mb-1">üîÆ</span>
                            <span class="text-xs">Spell</span>
                        </button>
                        
                        <!-- Ambient/Misc -->
                        <button onclick="playTone('mystery')" class="sound-btn bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 rounded-lg shadow-lg border-b-4 border-indigo-800 flex flex-col items-center justify-center">
                            <span class="text-2xl mb-1">üëª</span>
                            <span class="text-xs">Mystery</span>
                        </button>
                        <button onclick="playTone('rest')" class="sound-btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-lg shadow-lg border-b-4 border-blue-800 flex flex-col items-center justify-center">
                            <span class="text-2xl mb-1">üí§</span>
                            <span class="text-xs">Rest</span>
                        </button>
                        <button onclick="playTone('trap')" class="sound-btn bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-4 rounded-lg shadow-lg border-b-4 border-yellow-800 flex flex-col items-center justify-center">
                            <span class="text-2xl mb-1">‚ö†Ô∏è</span>
                            <span class="text-xs">Trap!</span>
                        </button>
                        <button onclick="playTone('boss')" class="sound-btn bg-gray-700 hover:bg-gray-600 text-white font-bold py-4 rounded-lg shadow-lg border-b-4 border-gray-900 flex flex-col items-center justify-center">
                            <span class="text-2xl mb-1">üíÄ</span>
                            <span class="text-xs">Boss</span>
                        </button>
                    </div>

                    <!-- Ambience Loops -->
                    <h3 class="text-sm font-semibold text-gray-400 mb-2 uppercase tracking-wider border-t border-gray-700 pt-4">Generative Ambience Loops (Click to Toggle)</h3>
                    <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                        <button onclick="toggleAmbience('village')" id="ambience-village" class="sound-btn bg-teal-800 hover:bg-teal-700 text-white font-bold py-3 rounded-lg shadow-md border border-teal-600 flex flex-col items-center justify-center">
                            <span class="text-xl mb-1">üèòÔ∏è</span>
                            <span class="text-xs">Village Market</span>
                        </button>
                        <button onclick="toggleAmbience('city')" id="ambience-city" class="sound-btn bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded-lg shadow-md border border-gray-500 flex flex-col items-center justify-center">
                            <span class="text-xl mb-1">üè∞</span>
                            <span class="text-xs">City Life</span>
                        </button>
                        <button onclick="toggleAmbience('tavern')" id="ambience-tavern" class="sound-btn bg-yellow-900 hover:bg-yellow-800 text-white font-bold py-3 rounded-lg shadow-md border border-yellow-700 flex flex-col items-center justify-center">
                            <span class="text-xl mb-1">üç∫</span>
                            <span class="text-xs">Tavern</span>
                        </button>
                        <button onclick="toggleAmbience('ocean')" id="ambience-ocean" class="sound-btn bg-blue-900 hover:bg-blue-800 text-white font-bold py-3 rounded-lg shadow-md border border-blue-700 flex flex-col items-center justify-center">
                            <span class="text-xl mb-1">‚öì</span>
                            <span class="text-xs">Sea Shanty</span>
                        </button>
                        <button onclick="toggleAmbience('dungeon')" id="ambience-dungeon" class="sound-btn bg-purple-900 hover:bg-purple-800 text-white font-bold py-3 rounded-lg shadow-md border border-purple-700 flex flex-col items-center justify-center">
                            <span class="text-xl mb-1">‚õìÔ∏è</span>
                            <span class="text-xs">Dungeon</span>
                        </button>
                        <button onclick="toggleAmbience('battle_minor')" id="ambience-battle_minor" class="sound-btn bg-red-900 hover:bg-red-800 text-white font-bold py-3 rounded-lg shadow-md border border-red-700 flex flex-col items-center justify-center">
                            <span class="text-xl mb-1">üõ°Ô∏è</span>
                            <span class="text-xs">Battle (Minor)</span>
                        </button>
                        <button onclick="toggleAmbience('battle_major')" id="ambience-battle_major" class="sound-btn bg-gray-800 hover:bg-gray-700 text-white font-bold py-3 rounded-lg shadow-md border border-gray-600 flex flex-col items-center justify-center">
                            <span class="text-xl mb-1">üî•</span>
                            <span class="text-xs">Battle (Major)</span>
                        </button>
                        <button onclick="toggleAmbience('sleep')" id="ambience-sleep" class="sound-btn bg-indigo-900 hover:bg-indigo-800 text-white font-bold py-3 rounded-lg shadow-md border border-indigo-700 flex flex-col items-center justify-center col-span-1 sm:col-span-1">
                            <span class="text-xl mb-1">‚õ∫üí§</span>
                            <span class="text-xs">Campfire Rest</span>
                        </button>
                    </div>
                    <div id="ambience-status" class="mt-2 text-center text-xs text-green-400 h-4"></div>
                </div>
            </div>

            <!-- 5. Rulings & Notes (was 4) -->
            <div id="notes" class="tab-content hidden">
                <div class="card p-4 rounded-lg shadow-xl">
                    <h2 class="text-xl font-semibold mb-4 text-indigo-300">Collapsible & Editable Prep Notes</h2>
                    <p class="text-sm text-gray-400 mb-4">Your generated content and custom notes are now saved as a **collapsible list** for better organization.</p>
                    
                    <!-- Sub-Tab Navigation -->
                    <div class="flex border-b border-gray-700 mb-4 -mx-4 px-4">
                        <button class="sub-tab-button p-2 text-sm font-semibold transition duration-300 active" data-subtab="prepNotes" onclick="switchSubTab('prepNotes')">
                            üìú General Notes
                        </button>
                        <button class="sub-tab-button p-2 text-sm font-semibold text-gray-400 transition duration-300" data-subtab="enemyNotes" onclick="switchSubTab('enemyNotes')">
                            üíÄ Enemies
                        </button>
                        <button class="sub-tab-button p-2 text-sm font-semibold text-gray-400 transition duration-300" data-subtab="npcNotes" onclick="switchSubTab('npcNotes')">
                            üë• NPCs
                        </button>
                    </div>

                    <!-- Sub-Tab Content: Notes List -->
                    <div id="prepNotes-sub-content" class="sub-tab-content">
                        <div id="prepNotes-list" class="scrollable-content space-y-3">
                            <!-- Notes will be rendered here -->
                        </div>
                    </div>
                    <!-- Sub-Tab Content: Enemies List -->
                    <div id="enemyNotes-sub-content" class="sub-tab-content hidden">
                        <div id="enemyNotes-list" class="scrollable-content space-y-3">
                            <!-- Enemy notes will be rendered here -->
                        </div>
                    </div>
                    <!-- Sub-Tab Content: NPCs List -->
                    <div id="npcNotes-sub-content" class="sub-tab-content hidden">
                        <div id="npcNotes-list" class="scrollable-content space-y-3">
                            <!-- NPC notes will be rendered here -->
                        </div>
                    </div>

                    <!-- Button to add a new manual note -->
                    <button onclick="addNewNote(currentSubTab)" class="mt-4 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 rounded-lg transition duration-300">
                        + Add Manual Note
                    </button>
                    <p id="notes-status" class="mt-2 text-sm text-center text-gray-400"></p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notes Editing MODAL (For Rulings & Notes) -->
    <div id="edit-modal" class="hidden fixed inset-0 z-50 bg-black bg-opacity-75 flex items-center justify-center p-4">
        <div class="card w-full max-w-lg p-6 rounded-lg shadow-2xl">
            <h3 class="text-xl font-bold text-indigo-300 mb-4">Edit Note</h3>
            <input type="hidden" id="modal-note-id">
            <input type="hidden" id="modal-tab-name">

            <label for="modal-title" class="block text-sm font-medium text-gray-400 mb-1">Title</label>
            <input type="text" id="modal-title" class="w-full p-3 rounded-lg input-style mb-4">

            <label for="modal-content" class="block text-sm font-medium text-gray-400 mb-1">Content</label>
            <textarea id="modal-content" rows="6" class="w-full p-3 rounded-lg input-style mb-6 resize-none"></textarea>

            <div class="flex justify-end space-x-3">
                <button onclick="closeEditModal()" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Cancel</button>
                <button onclick="saveEditedNote()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Save Changes</button>
            </div>
        </div>
    </div>
    
    <!-- Statblock Editing MODAL (NEW) -->
    <div id="edit-statblock-modal" class="hidden fixed inset-0 z-50 bg-black bg-opacity-75 flex items-center justify-center p-4">
        <div class="card w-full max-w-lg p-6 rounded-lg shadow-2xl">
            <h3 class="text-xl font-bold text-indigo-300 mb-4">Edit Statblock</h3>
            <input type="hidden" id="modal-statblock-id">

            <label for="modal-stat-name" class="block text-sm font-medium text-gray-400 mb-1">Name</label>
            <input type="text" id="modal-stat-name" placeholder="Name" class="w-full p-3 rounded-lg input-style mb-4">

            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="modal-stat-hp" class="block text-sm font-medium text-gray-400 mb-1">HP</label>
                    <input type="number" id="modal-stat-hp" placeholder="HP" class="w-full p-3 rounded-lg input-style text-center text-sm mb-4">
                </div>
                <div>
                    <label for="modal-stat-ac" class="block text-sm font-medium text-gray-400 mb-1">AC</label>
                    <input type="number" id="modal-stat-ac" placeholder="AC" class="w-full p-3 rounded-lg input-style text-center text-sm mb-4">
                </div>
                <div>
                    <label for="modal-stat-tohit" class="block text-sm font-medium text-gray-400 mb-1">To Hit Mod</label>
                    <input type="number" id="modal-stat-tohit" placeholder="To Hit Mod" class="w-full p-3 rounded-lg input-style text-center text-sm mb-4">
                </div>
                <div>
                    <label for="modal-stat-init-mod" class="block text-sm font-medium text-gray-400 mb-1">Init Mod</label>
                    <input type="number" id="modal-stat-init-mod" placeholder="Init Mod" class="w-full p-3 rounded-lg input-style text-center text-sm mb-4">
                </div>
            </div>

            <label for="modal-stat-dmg" class="block text-sm font-medium text-gray-400 mb-1">Attack DMG (e.g., 1d8+2)</label>
            <input type="text" id="modal-stat-dmg" placeholder="Attack DMG" class="w-full p-3 rounded-lg input-style mb-6">


            <div class="flex justify-end space-x-3">
                <button onclick="closeStatblockEditModal()" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Cancel</button>
                <button onclick="saveEditedStatblock()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Save Changes</button>
            </div>
        </div>
    </div>
    
    <script>
        // --- Core Application Logic ---

        let currentTab = 'improv'; 
        let currentSubTab = 'prepNotes';
        let savedStatblocks = []; 
        let lastGeneratedNpc = null;
        let lastGeneratedMonster = null; // ADDED
        let structuredNotes = {
            prepNotes: [],
            enemyNotes: [],
            npcNotes: []
        };

        // --- Global Variable for API Key ---
        let userApiKey = localStorage.getItem('dm_toolkit_api_key') || "";


        // --- Firebase/Data Functions (using the global variables defined in the module script) ---
        
        // Data is now saved to a PUBLIC path for sharing/collaboration
        
        function getUserDocRef() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // NEW PUBLIC PATH for Notes
            return window.doc(window.db, 'artifacts', appId, 'public', 'data', 'dm_toolkit_data', 'shared_notes');
        }
        
        function getCombatDocRef() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // NEW PUBLIC PATH for Combat Tracker
            return window.doc(window.db, 'artifacts', appId, 'public', 'data', 'dm_toolkit_data', 'shared_combat');
        }

        // --- NEW DATA STRUCTURE ---
        // We will now store combatants in their own collection to prevent race conditions
        // and store the turn order in a separate state document.
        
        /**
         * NEW: Gets the reference to the COLLECTION holding all combatant documents.
         */
        function getCombatantsCollectionRef() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // NEW PUBLIC PATH for Combatants Collection
            return window.collection(window.db, 'artifacts', appId, 'public', 'data', 'shared_combatants');
        }
        
        /**
         * NEW: Gets the reference to the DOCUMENT holding the combat state (e.g., current turn).
         */
        function getCombatStateDocRef() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // NEW PUBLIC PATH for Combat State Doc
            return window.doc(window.db, 'artifacts', appId, 'public', 'data', 'dm_toolkit_data', 'shared_combat_state');
        }

        function getStatblocksCollectionRef() {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // NEW PUBLIC PATH for Statblocks Collection
            return window.collection(window.db, 'artifacts', appId, 'public', 'data', 'dm_toolkit_statblocks');
        }

        // --- Structured Notes Logic ---
        
        // Helper to generate Firestore key name
        function getFirestoreKey(tabName) {
            return `structured${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`;
        }

        window.saveStructuredNotes = async function(tabName, notesArray) {
            if (!window.isAuthReady || !window.db) {
                document.getElementById('notes-status').textContent = 'Database not ready. Please wait for authentication.';
                return;
            }

            const statusElement = document.getElementById('notes-status');
            statusElement.textContent = `Saving ${tabName}...`;
            
            const firestoreKey = getFirestoreKey(tabName);
            const dataToSave = {};
            dataToSave[firestoreKey] = notesArray;
            dataToSave.lastSaved = new Date().toISOString();

            try {
                // Using setDoc with merge to ensure we only update the specific notes field
                await window.setDoc(getUserDocRef(), dataToSave, { merge: true });
                statusElement.textContent = `${tabName} saved successfully!`;
            } catch (error) {
                console.error("Error saving structured notes: ", error);
                statusElement.textContent = 'Error saving notes. Check console for details.';
            }
        }
        
        window.setupNotesListener = function() {
            if (!window.isAuthReady || !window.db) return;

            window.onSnapshot(getUserDocRef(), (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    
                    structuredNotes.prepNotes = data[getFirestoreKey('prepNotes')] || [];
                    structuredNotes.enemyNotes = data[getFirestoreKey('enemyNotes')] || [];
                    structuredNotes.npcNotes = data[getFirestoreKey('npcNotes')] || [];

                    // Only re-render the currently visible sub-tab for efficiency
                    if (currentTab === 'notes') {
                        renderStructuredNotes('prepNotes');
                        renderStructuredNotes('enemyNotes');
                        renderStructuredNotes('npcNotes');
                    }
                } else {
                    // It's normal for the doc to not exist yet. We just log it.
                    console.log("Notes document does not exist yet. Will be created on first save.");
                }
            }, (error) => {
                // Add error handling for the listener itself
                console.error("Error setting up notes listener: ", error);
            });
        } 
        
        // --- FIX 5: Added missing function declaration ---
        function renderStructuredNotes(tabName) {
            const notesArray = structuredNotes[tabName];
            const listContainer = document.getElementById(`${tabName}-list`);
            
            if (!listContainer) {
                console.error(`Container not found for ${tabName}-list`);
                return;
            }

            listContainer.innerHTML = ''; // Clear current notes

            if (!notesArray || notesArray.length === 0) {
                listContainer.innerHTML = `<p class="text-center text-gray-500 pt-8">No notes in this category yet. Add one manually or save from the Improv tab!</p>`;
                return;
            }

            notesArray.forEach(note => {
                const noteElement = document.createElement('div');
                noteElement.className = 'note-item card p-0 rounded-lg shadow-md';
                noteElement.id = `note-${note.id}`;

                // Header with Collapse Toggle
                const header = document.createElement('div');
                header.className = 'collapsible-header hover:bg-gray-600/50 transition duration-150';
                header.onclick = () => toggleCollapse(note.id);
                header.innerHTML = `
                    <span class="font-semibold text-lg text-indigo-300 truncate">${note.title}</span>
                    <svg class="arrow-icon w-4 h-4 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                    </svg>
                `;

                // Content Area
                const content = document.createElement('div');
                content.className = 'collapsible-content';
                content.id = `content-${note.id}`;
                
                // Check if content looks like HTML (basic check)
                const isHtml = /<[a-z][\s\S]*>/i.test(note.content);
                
                if (isHtml) {
                    // If it's HTML (likely a monster stat block), just render it directly
                    content.innerHTML = `
                        <div class="p-2">
                            ${note.content}
                        </div>
                        <div class="flex justify-end space-x-2 pt-2 pb-1">
                            <button onclick="editNote('${note.id}', '${tabName}')" class="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1 px-3 rounded transition duration-300">Edit</button>
                            <button onclick="deleteNote('${note.id}', '${tabName}')" class="bg-red-600 hover:bg-red-700 text-white text-xs font-bold py-1 px-3 rounded transition duration-300">Delete</button>
                        </div>
                    `;
                } else {
                    // If it's plain text (from creative generator), wrap it
                    content.innerHTML = `
                        <div class="whitespace-pre-wrap text-sm text-gray-300 p-2 border-l-4 border-indigo-400 bg-gray-700/50">
                            ${note.content}
                        </div>
                        <div class="flex justify-end space-x-2 pt-2 pb-1">
                            <button onclick="editNote('${note.id}', '${tabName}')" class="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1 px-3 rounded transition duration-300">Edit</button>
                            <button onclick="deleteNote('${note.id}', '${tabName}')" class="bg-red-600 hover:bg-red-700 text-white text-xs font-bold py-1 px-3 rounded transition duration-300">Delete</button>
                        </div>
                    `;
                }
                
                noteElement.appendChild(header);
                noteElement.appendChild(content);
                listContainer.appendChild(noteElement);
            });
        // --- FIX 6: Added missing closing brace for the function ---
        }
        
        // Toggles the visibility of the note content
        window.toggleCollapse = function(noteId) {
            const content = document.getElementById(`content-${noteId}`);
            // Fix: Check for null element before accessing classList
            if (!content) {
                console.error(`Failed to find content element with ID: content-${noteId}`);
                return;
            }
            const isExpanded = content.classList.contains('expanded');

            if (isExpanded) {
                content.classList.remove('expanded');
                content.style.maxHeight = null;
            } else {
                content.classList.add('expanded');
                // Set max-height to scroll height to allow smooth transition on expanding
                content.style.maxHeight = content.scrollHeight + "px";
            }
        }
        
        // Handles adding a blank note manually
        window.addNewNote = function(tabName) {
            const newNote = {
                id: crypto.randomUUID(),
                title: 'New Manual Note (Click Edit to change)',
                content: 'Start typing your detailed note content here.',
                timestamp: new Date().toISOString()
            };
            structuredNotes[tabName].unshift(newNote); // Add to beginning
            saveStructuredNotes(tabName, structuredNotes[tabName]);
        }
        
        // Handles deleting a note
        window.deleteNote = function(noteId, tabName) {
            const newArray = structuredNotes[tabName].filter(note => note.id !== noteId);
            structuredNotes[tabName] = newArray;
            saveStructuredNotes(tabName, newArray);
        }

        // --- NOTES MODAL EDITING LOGIC ---
        
        /**
         * Opens the custom modal for editing the note.
         */
        window.editNote = function(noteId, tabName) {
            const note = structuredNotes[tabName].find(n => n.id === noteId);
            if (!note) {
                document.getElementById('notes-status').textContent = 'Error: Note not found.';
                return;
            }

            // Populate modal fields
            document.getElementById('modal-note-id').value = note.id;
            document.getElementById('modal-tab-name').value = tabName;
            document.getElementById('modal-title').value = note.title;
            document.getElementById('modal-content').value = note.content;

            // Show the modal
            document.getElementById('edit-modal').classList.remove('hidden');
            document.getElementById('notes-status').textContent = ''; // Clear status message
        }
        
        /**
         * Closes the custom modal.
         */
        window.closeEditModal = function() {
            document.getElementById('edit-modal').classList.add('hidden');
            // Provide a subtle cancellation message
            document.getElementById('notes-status').textContent = 'Edit cancelled.'; 
        }

        /**
         * Saves changes from the custom modal inputs.
         */
        window.saveEditedNote = function() {
            const statusElement = document.getElementById('notes-status');
            const noteId = document.getElementById('modal-note-id').value;
            const tabName = document.getElementById('modal-tab-name').value;
            const newTitle = document.getElementById('modal-title').value.trim();
            const newContent = document.getElementById('modal-content').value.trim();

            const noteIndex = structuredNotes[tabName].findIndex(note => note.id === noteId);
            if (noteIndex === -1) {
                statusElement.textContent = 'Error: Note not found during save.';
                document.getElementById('edit-modal').classList.add('hidden'); // Close modal on error
                return;
            }

            const oldNote = structuredNotes[tabName][noteIndex];

            const finalTitle = newTitle || 'Untitled Note';
            const finalContent = newContent;

            if (finalTitle !== oldNote.title || finalContent !== oldNote.content) {
                // Change detected, update the local structure
                structuredNotes[tabName][noteIndex].title = finalTitle;
                structuredNotes[tabName][noteIndex].content = finalContent;
                
                // Save the updated array to Firestore (this will trigger a re-render)
                saveStructuredNotes(tabName, structuredNotes[tabName]);
                statusElement.textContent = `Note "${finalTitle}" updated and saved!`;

                // Collapse content after edit and save for a clean closure
                const contentDiv = document.getElementById(`content-${noteId}`);
                if(contentDiv && contentDiv.classList.contains('expanded')) {
                      contentDiv.classList.remove('expanded');
                      contentDiv.style.maxHeight = null;
                }

            } else {
                // No change detected
                statusElement.textContent = 'No changes detected. Note was not saved.';
            }

            document.getElementById('edit-modal').classList.add('hidden'); // Always close the modal
        }
        
        // --- End NOTES MODAL EDITING LOGIC ---


        // --- Combat Data Persistence (Initiative Tracker) ---
        let combatants = [];
        let currentTurnIndex = -1;
        let lastRoll = 0;

        /**
         * REFACTORED: This function now only saves the combat's *state* (current turn).
         * Combatants are saved individually by other functions.
         */
        async function saveCombatStateToFirestore() {
            if (!window.isAuthReady || !window.db) {
                console.warn("Firestore not ready. Cannot save combat state.");
                return;
            }
            try {
                await window.setDoc(getCombatStateDocRef(), {
                    currentTurnIndex: currentTurnIndex
                });
            } catch (error) {
                console.error("Error saving combat state:", error);
            }
        }

        /**
         * REFACTORED: Renamed and split into two listeners for the new data structure.
         */
        window.setupCombatDataListeners = function() {
            if (!window.isAuthReady || !window.db) return;
            
            const dbStatus = document.getElementById('db-status');
            if(dbStatus) dbStatus.textContent = "Connecting...";

            // --- LISTENER 1: For the combatants list ---
            // REFACTORED: Removed .orderBy() from the query to avoid needing a Firestore index.
            // We will now sort the data in-memory in JavaScript.
            const combatantsQuery = window.query(getCombatantsCollectionRef());
            
            window.onSnapshot(combatantsQuery, (snapshot) => {
                const loadedCombatants = [];
                snapshot.forEach(doc => {
                    loadedCombatants.push({ id: doc.id, ...doc.data() });
                });
                
                // NEW: Sort the data here in JavaScript instead of in the query
                loadedCombatants.sort((a, b) => (b.init || 0) - (a.init || 0)); // Sort descending by init

                combatants = loadedCombatants;
                // We call renderCombatants() here to show the new sorted list
                renderCombatants();
                console.log("Combatants list updated from Firestore and sorted in-memory.");
                
                if(dbStatus) {
                    dbStatus.textContent = "Connected";
                    dbStatus.classList.remove('text-red-400', 'text-gray-400');
                    dbStatus.classList.add('text-green-400');
                }
                
            }, (error) => {
                console.error("Error setting up combatants listener: ", error);
                if(dbStatus) {
                    dbStatus.textContent = "Disconnected";
                    dbStatus.classList.remove('text-green-400', 'text-gray-400');
                    dbStatus.classList.add('text-red-400');
                }
                // Alert the user if permissions fail
                const list = document.getElementById('initiative-list');
                if(list) list.innerHTML = `<p class="text-center text-red-400 pt-8">Error loading data: ${error.message}</p>`;
            });

            // --- LISTENER 2: For the combat state (turn index) ---
            // Listens to the separate state document
            window.onSnapshot(getCombatStateDocRef(), (doc) => {
                if (doc.exists()) {
                    const data = doc.data();
                    currentTurnIndex = data.currentTurnIndex !== undefined ? data.currentTurnIndex : -1;
                } else {
                    currentTurnIndex = -1;
                }
                // We also call renderCombatants() here to highlight the active turn
                renderCombatants();
                console.log("Combat state (turn) updated from Firestore.");
                
            }, (error) => {
                console.error("Error setting up combat state listener: ", error);
            });
        }
        
        // --- Statblock Logic (Updated with Edit button and modal functions) ---
        
        window.saveStatblock = async function() {
            if (!window.isAuthReady || !window.db) {
                document.getElementById('statblock-status').textContent = 'Database not ready. Please wait for authentication.';
                return;
            }
            
            const name = document.getElementById('stat-name').value.trim();
            const hp = parseInt(document.getElementById('stat-hp').value, 10) || 0;
            const ac = parseInt(document.getElementById('stat-ac').value, 10) || 0;
            const toHit = parseInt(document.getElementById('stat-tohit').value, 10) || 0;
            const initMod = parseInt(document.getElementById('stat-init-mod').value, 10) || 0;
            const dmg = document.getElementById('stat-dmg').value.trim();
            const statusElement = document.getElementById('statblock-status');

            // --- REVERTED: This is the original, strict validation ---
            if (!name || hp <= 0 || ac <= 0 || !dmg) {
                 statusElement.textContent = 'Please fill out Name, HP, AC, and Attack DMG.';
                 return;
            }
            
            statusElement.textContent = 'Saving...';

            try {
                await window.addDoc(getStatblocksCollectionRef(), {
                    name,
                    hp,
                    ac,
                    toHit,
                    initMod,
                    dmg,
                    timestamp: new Date().toISOString()
                });
                statusElement.textContent = `${name} saved successfully!`;
                // Clear inputs
                document.getElementById('stat-name').value = '';
                document.getElementById('stat-hp').value = '';
                document.getElementById('stat-ac').value = '';
                document.getElementById('stat-tohit').value = '';
                document.getElementById('stat-init-mod').value = '';
                document.getElementById('stat-dmg').value = '';

            } catch (error) {
                console.error("Error saving statblock: ", error);
                statusElement.textContent = `Error saving statblock. See console for details. (Error: ${error.message})`;
            }
        }
        
        window.addNpcToStatblocks = async function () {
            const statusElement = document.getElementById('npc-save-status');

            if (!window.isAuthReady || !window.db) {
                statusElement.textContent = 'Database not ready. Please wait for authentication.';
                statusElement.classList.remove('hidden');
                return;
            }
            if (!lastGeneratedNpc) {
                statusElement.textContent = 'No NPC data to save.';
                statusElement.classList.remove('hidden');
                return;
            }

            const npc = lastGeneratedNpc;
            
            let toHit = 0;
            const match = npc.main_attack.match(/(\+|\-)\d+/);
            if (match) {
                toHit = parseInt(match[0], 10);
            } else {
                toHit = npc.initiative_bonus || 0;
            }

            const dmg = npc.main_attack; 

            statusElement.textContent = `Saving ${npc.name} to Statblocks...`;
            statusElement.classList.remove('hidden');
            statusElement.classList.remove('text-red-400', 'text-green-400');
            statusElement.classList.add('text-yellow-400');

            try {
                await window.addDoc(getStatblocksCollectionRef(), {
                    name: npc.name,
                    hp: npc.max_hit_points,
                    ac: npc.armor_class_ac,
                    toHit: toHit,
                    initMod: npc.initiative_bonus,
                    dmg: dmg,
                    timestamp: new Date().toISOString()
                });
                
                statusElement.textContent = `${npc.name} added to Statblocks! (To Hit: ${toHit >= 0 ? '+' : ''}${toHit})`;
                statusElement.classList.remove('text-yellow-400');
                statusElement.classList.add('text-green-400');

            } catch (error) {
                console.error("Error saving generated statblock: ", error);
                statusElement.textContent = `Error saving statblock: ${error.message}`;
                statusElement.classList.remove('text-yellow-400');
                statusElement.classList.add('text-red-400');
            }
        }

        window.setupStatblocksListener = function() {
            if (!window.isAuthReady || !window.db) return;

            window.onSnapshot(window.query(getStatblocksCollectionRef()), (snapshot) => {
                savedStatblocks = [];
                snapshot.forEach(doc => {
                    savedStatblocks.push({ id: doc.id, ...doc.data() });
                });
                // Sort by name alphabetically
                savedStatblocks.sort((a, b) => a.name.localeCompare(b.name));
                renderStatblocks();
                console.log(`Loaded ${savedStatblocks.length} statblocks.`);
            }, (error) => {
                console.error("Error setting up statblocks listener: ", error);
            });
        }

        function renderStatblocks() {
            const list = document.getElementById('statblocks-list');
            list.innerHTML = '';

            if (savedStatblocks.length === 0) {
                list.innerHTML = '<p class="text-center text-gray-500 pt-8">Your saved NPCs and monsters will appear here.</p>';
                return;
            }

            savedStatblocks.forEach(stat => {
                const hp = stat.hp || 0;
                const ac = stat.ac || 0;
                const toHit = stat.toHit || 0;
                const initMod = stat.initMod || 0;

                // --- MODIFIED: Use collapsible structure ---
                const element = document.createElement('div');
                element.className = 'note-item card p-0 rounded-lg shadow-md'; // Use same class as notes
                const uniqueId = `statblock-${stat.id}`;
                element.id = uniqueId;

                // Header with Collapse Toggle
                const header = document.createElement('div');
                header.className = 'collapsible-header hover:bg-gray-600/50 transition duration-150';
                header.onclick = () => toggleCollapse(uniqueId);
                header.innerHTML = `
                    <span class="font-semibold text-lg text-indigo-300 truncate">${stat.name}</span>
                    <svg class="arrow-icon w-4 h-4 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                    </svg>
                `;
                
                // Content Area
                const content = document.createElement('div');
                content.className = 'collapsible-content'; // Starts collapsed
                content.id = `content-${uniqueId}`; // Matches what toggleCollapse() expects

                // Inner content (the original statblock details, now with padding)
                content.innerHTML = `
                    <div class="p-3"> 
                        <div class="flex justify-end space-x-2 mb-2">
                            <button onclick="editStatblock('${stat.id}')" class="bg-blue-600 hover:bg-blue-700 text-white text-xs font-bold py-1 px-2 rounded transition duration-300">Edit</button>
                            <button onclick="deleteStatblock('${stat.id}')" class="bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-2 rounded transition duration-300">Delete</button>
                        </div>
                        <div class="grid grid-cols-2 text-sm gap-y-1 text-gray-300">
                            <span class="font-semibold text-green-400">HP: ${hp}</span>
                            <span class="font-semibold text-blue-400">AC: ${ac}</span>
                            <span>Init Mod: ${initMod > 0 ? '+' : ''}${initMod}</span>
                            <span>To Hit: ${toHit > 0 ? '+' : ''}${toHit}</span>
                            <div class="col-span-2 text-yellow-400 text-xs mt-1">
                                <span class="font-semibold text-sm">DMG/Attack:</span>
                                ${stat.dmg}
                            </div>
                        </div>
                        <button onclick="importToCombat('${stat.name}', ${hp}, ${initMod}, ${ac})" class="mt-3 w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 rounded-lg transition duration-300 text-sm">
                            Add to Combat Tracker
                        </button>
                    </div>
                `;
                
                element.appendChild(header);
                element.appendChild(content);
                // --- END MODIFICATION ---

                list.appendChild(element);
            });
        }
        
        /**
         * Opens the custom modal for editing the statblock.
         */
        window.editStatblock = function(statId) {
            const stat = savedStatblocks.find(s => s.id === statId);
            if (!stat) return;

            // Populate modal fields
            document.getElementById('modal-statblock-id').value = stat.id;
            document.getElementById('modal-stat-name').value = stat.name;
            document.getElementById('modal-stat-hp').value = stat.hp;
            document.getElementById('modal-stat-ac').value = stat.ac;
            document.getElementById('modal-stat-tohit').value = stat.toHit;
            document.getElementById('modal-stat-init-mod').value = stat.initMod;
            document.getElementById('modal-stat-dmg').value = stat.dmg;

            // Show the modal
            document.getElementById('edit-statblock-modal').classList.remove('hidden');
            document.getElementById('statblock-status').textContent = ''; // Clear status message
        }

        /**
         * Closes the statblock editing modal.
         */
        window.closeStatblockEditModal = function() {
            document.getElementById('edit-statblock-modal').classList.add('hidden');
            document.getElementById('statblock-status').textContent = 'Edit cancelled.';
        }
        
        /**
         * Saves changes from the statblock modal inputs to Firestore.
         */
        window.saveEditedStatblock = async function() {
            if (!window.isAuthReady || !window.db) {
                document.getElementById('statblock-status').textContent = 'Database not ready. Please wait for authentication.';
                return;
            }

            const statId = document.getElementById('modal-statblock-id').value;
            const name = document.getElementById('modal-stat-name').value.trim();
            const hp = parseInt(document.getElementById('modal-stat-hp').value, 10) || 0;
            const ac = parseInt(document.getElementById('modal-stat-ac').value, 10) || 0;
            const toHit = parseInt(document.getElementById('modal-stat-tohit').value, 10) || 0;
            const initMod = parseInt(document.getElementById('modal-stat-init-mod').value, 10) || 0;
            const dmg = document.getElementById('modal-stat-dmg').value.trim();
            const statusElement = document.getElementById('statblock-status');

            // --- REVERTED: This is the original, strict validation ---
            if (!name || hp <= 0 || ac <= 0 || !dmg) {
                 statusElement.textContent = 'Name, HP, AC, and Damage are required.';
                 return;
            }

            const docRef = window.doc(getStatblocksCollectionRef(), statId);
            
            try {
                // Use setDoc with merge to update the existing document
                await window.setDoc(docRef, {
                    name, 
                    hp, 
                    ac, 
                    toHit, 
                    initMod, 
                    dmg
                }, { merge: true });

                statusElement.textContent = `Statblock "${name}" updated successfully!`;
                closeStatblockEditModal();
            } catch (error) {
                console.error("Error updating statblock: ", error);
                statusElement.textContent = `Error updating statblock: ${error.message}`;
            }
        }


        window.deleteStatblock = async function(docId) {
            if (!window.isAuthReady || !window.db) return;
            try {
                const docRef = window.doc(getStatblocksCollectionRef(), docId);
                await window.deleteDoc(docRef);
            } catch (error) {
                console.error("Error deleting statblock: ", error);
            }
        }
        
        // UPDATED: Added AC parameter to importToCombat
        window.importToCombat = function(name, hp, initMod, ac) {
            document.getElementById('combatant-name').value = name;
            document.getElementById('combatant-hp').value = hp;
            document.getElementById('combatant-init').value = initMod; 
            document.getElementById('combatant-ac').value = ac; // New: Populate AC field
            
            switchTab('combat');
        }


        // --- UI Logic (Shared) ---

        window.switchTab = function(tabId) {
            currentTab = tabId;
            document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
            document.getElementById(tabId).classList.remove('hidden');

            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
                btn.classList.add('text-gray-400');
                // UPDATED to include 'monsters', 'loot', and 'soundboard'
                if (btn.textContent.includes(
                    tabId === 'improv' ? 'Prep & Improv' :
                    tabId === 'combat' ? 'Combat' :
                    tabId === 'statblocks' ? 'Stats' :
                    tabId === 'monsters' ? 'Monsters' :
                    tabId === 'loot' ? 'Loot' :
                    tabId === 'soundboard' ? 'Sound' :
                    'Notes' // Default for 'notes'
                )) {
                      btn.classList.add('active');
                      btn.classList.remove('text-gray-400');
                }
            });
            // Ensure the correct sub-tab is displayed when switching to Notes
            if (tabId === 'notes') {
                switchSubTab(currentSubTab);
            }
        }
        
        // Sub-Tab switching logic for Notes
        window.switchSubTab = function(tabId) {
            currentSubTab = tabId;
            document.querySelectorAll('.sub-tab-content').forEach(el => el.classList.add('hidden'));
            document.getElementById(`${tabId}-sub-content`).classList.remove('hidden');

            document.querySelectorAll('.sub-tab-button').forEach(btn => {
                btn.classList.remove('active', 'text-gray-400');
                if (btn.dataset.subtab === tabId) {
                      btn.classList.add('active');
                      btn.classList.remove('text-gray-400');
                } else {
                      btn.classList.add('text-gray-400');
                }
            });
            // Rerender notes to handle any potential loading issues
            renderStructuredNotes(currentSubTab);
        }


        // --- Gemini API Logic (Core) ---
        const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=';
        const IMAGE_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=`; // NEW
        const apiKey = "PASTE_YOUR_NEW_KEY_HERE"; // PASTE YOUR NEW API KEY HERE

        // Define the required structured output format for combat stats
        const combatSchema = {
            type: "OBJECT",
            properties: {
                name: { "type": "STRING", "description": "A creative and appropriate name for the NPC." },
                level_or_cr: { "type": "STRING", "description": "The requested level or challenge rating." },
                armor_class_ac: { "type": "INTEGER", "description": "The NPC's calculated Armor Class (AC)." },
                max_hit_points: { "type": "INTEGER", "description": "The NPC's maximum Hit Points (HP)." },
                initiative_bonus: { "type": "INTEGER", "description": "The modifier (DEX bonus) added to the d20 roll for initiative." },
                main_attack: { "type": "STRING", "description": "The NPC's primary attack description including attack roll modifier and damage (e.g., '+5 to hit, 1d12+3 slashing damage')." }
            },
            required: ["name", "level_or_cr", "armor_class_ac", "max_hit_points", "initiative_bonus", "main_attack"]
        };

        // Define the required structured output format for monster stat blocks
        const monsterSchema = {
            type: "OBJECT",
            properties: {
                name: { type: "STRING", description: "The monster's name." },
                size: { type: "STRING", description: "Size (e.g., Medium, Large)." },
                type: { type: "STRING", description: "Type (e.g., humanoid, beast, monstrosity)." },
                alignment: { type: "STRING", description: "Alignment (e.g., chaotic evil, unaligned)." },
                armor_class: { type: "INTEGER", description: "Armor Class (AC)." },
                ac_type: { type: "STRING", description: "Type of AC (e.g., 'natural armor', 'plate mail')." },
                hit_points: { type: "INTEGER", description: "Average Hit Points." },
                hit_dice: { type: "STRING", description: "Hit Dice formula (e.g., '10d8 + 40')." },
                speed: { type: "STRING", description: "All movement speeds (e.g., '30 ft., fly 60 ft.')." },
                ability_scores: {
                    type: "OBJECT",
                    properties: {
                        STR: { type: "INTEGER" },
                        DEX: { type: "INTEGER" },
                        CON: { type: "INTEGER" },
                        INT: { type: "INTEGER" },
                        WIS: { type: "INTEGER" },
                        CHA: { type: "INTEGER" }
                    },
                    required: ["STR", "DEX", "CON", "INT", "WIS", "CHA"]
                },
                saving_throws: { 
                    type: "ARRAY", 
                    items: { type: "STRING" },
                    description: "List of saving throw proficiencies (e.g., 'DEX +5', 'CON +8')."
                },
                skills: { 
                    type: "ARRAY", 
                    items: { type: "STRING" },
                    description: "List of skill proficiencies (e.g., 'Perception +4', 'Stealth +5')."
                },
                damage_vulnerabilities: { type: "ARRAY", items: { type: "STRING" } },
                damage_resistances: { type: "ARRAY", items: { type: "STRING" } },
                damage_immunities: { type: "ARRAY", items: { type: "STRING" } },
                condition_immunities: { type: "ARRAY", items: { type: "STRING" } },
                senses: { type: "STRING", description: "Senses (e.g., 'darkvision 60 ft., passive Perception 14')." },
                languages: { type: "STRING", description: "Languages known (e.g., 'Common, Giant')." },
                challenge_rating: { type: "STRING", description: "Challenge Rating (CR) (e.g., '5')." },
                xp: { type: "INTEGER", description: "Experience Points (XP) for the CR." },
                abilities: {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            name: { type: "STRING" },
                            description: { type: "STRING" }
                        },
                        required: ["name", "description"]
                    },
                    description: "Special abilities (e.g., 'Pack Tactics', 'Magic Resistance')."
                },
                actions: {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            name: { type: "STRING" },
                            description: { type: "STRING" }
                        },
                        required: ["name", "description"]
                    },
                    description: "Actions the monster can take (e.g., 'Multiattack', 'Greataxe')."
                },
                legendary_actions: {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            name: { type: "STRING" },
                            description: { type: "STRING" }
                        },
                        required: ["name", "description"]
                    },
                    description: "Legendary actions, if any."
                }
            },
            required: ["name", "size", "type", "alignment", "armor_class", "hit_points", "hit_dice", "speed", "ability_scores", "senses", "languages", "challenge_rating", "xp", "actions"]
        };


        // --- MODE 1: Structured Combat Generation ---
        window.generateCombatNpc = async function() {
            const level = document.getElementById('npc-level').value.trim();
            const type = document.getElementById('npc-type').value.trim();

            if (!level || !type) {
                document.getElementById('combat-status-message').textContent = "Please provide both a level/CR and an NPC type.";
                document.getElementById('combat-status-message').classList.remove('hidden');
                return;
            }

            const button = document.getElementById('generate-combat-button');
            const buttonText = document.getElementById('generate-combat-text');
            const spinner = document.getElementById('combat-loading-spinner');
            const outputDiv = document.getElementById('ai-output');
            const saveStatusElement = document.getElementById('npc-save-status');

            document.getElementById('combat-status-message').classList.add('hidden');
            saveStatusElement.classList.add('hidden'); // Clear previous save status
            document.getElementById('save-options-creative').classList.add('hidden'); // Hide creative save buttons

            button.disabled = true;
            buttonText.textContent = 'Generating...';
            spinner.classList.remove('hidden');
            outputDiv.innerHTML = 'Generating combat stats...';
            lastGeneratedNpc = null; // Reset the last generated NPC

            const systemPrompt = `You are a dedicated and expert Tabletop RPG (TTRPG) Combat Encounter Generator. Your sole function is to create combat statistics for an NPC based on the provided level and type. You MUST return the data exactly according to the JSON schema provided. Assume a standard high-fantasy ruleset (like Dungeons & Dragons 5th Edition) for balancing.`;
            const userQuery = `Generate an NPC with a level/CR of ${level} and the description: ${type}.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: combatSchema
                },
            };

            try {
                const response = await fetchWithExponentialBackoff(API_URL + apiKey, payload);
                const result = await response.json();
                const jsonString = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (!jsonString) {
                    throw new Error("Received an empty or invalid response from the model.");
                }

                const npcStats = JSON.parse(jsonString);
                lastGeneratedNpc = npcStats; // Store the successful result

                // --- Render Structured Output ---
                const saveButtonsHtml = `
                    <p class="text-sm text-center text-gray-400 mt-4 mb-2">Save descriptive lore to Rulings & Notes (Collapsible):</p>
                    <div class="grid grid-cols-3 gap-2">
                        <button onclick="saveGeneratedContent('prepNotes')" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 rounded-lg transition duration-300 text-xs">Save to Notes</button>
                        <button onclick="saveGeneratedContent('enemyNotes')" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 rounded-lg transition duration-300 text-xs">Save to Enemies</button>
                        <button onclick="saveGeneratedContent('npcNotes')" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg transition duration-300 text-xs">Save to NPCs</button>
                    </div>
                `;

                let outputHtml = `
                    <div class="text-2xl font-bold text-green-400 mb-2">${npcStats.name}</div>
                    <div class="text-gray-300">Level/CR: <span class="font-medium text-white">${npcStats.level_or_cr}</span></div>
                    <div class="grid grid-cols-2 gap-3 mt-4">
                        <div class="p-3 bg-gray-600 rounded-lg">AC: <span class="font-semibold text-2xl block">${npcStats.armor_class_ac}</span></div>
                        <div class="p-3 bg-gray-600 rounded-lg">HP: <span class="font-semibold text-2xl block">${npcStats.max_hit_points}</span></div>
                        <div class="p-3 bg-gray-600 rounded-lg col-span-2">
                            <span class="text-gray-400">Initiative Bonus:</span> 
                            <span class="font-semibold text-2xl text-yellow-300">${npcStats.initiative_bonus >= 0 ? '+' : ''}${npcStats.initiative_bonus}</span>
                        </div>
                        <div class="p-3 bg-gray-600 rounded-lg col-span-2">
                            <span class="text-gray-400">Main Attack:</span> 
                            <span class="font-medium block mt-1">${npcStats.main_attack}</span>
                        </div>
                    </div>
                    <button onclick="addNpcToStatblocks()" class="mt-4 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 rounded-lg transition duration-300 flex items-center justify-center">
                        üíæ Add to Statblocks Tab (Quick Import)
                    </button>
                    ${saveButtonsHtml}
                `;
                outputDiv.innerHTML = outputHtml;

            } catch (error) {
                console.error("Combat Generation Error:", error);
                outputDiv.innerHTML = `<span class="text-red-400">Error generating combat stats: ${error.message}. Please try again.</span>`;
            } finally {
                button.disabled = false;
                buttonText.textContent = 'Generate Combat Stats';
                spinner.classList.add('hidden');
            }
        }
 
        // --- START: FIX FOR ReferenceError ---
        // --- MODE 2: Creative Lore Generation (Missing Function) ---
        window.generateCreativeIdea = async function() {
            const prompt = document.getElementById('improv-prompt').value.trim();

            if (!prompt) {
                document.getElementById('ai-output').innerHTML = '<span class="text-red-400">Please enter a prompt first.</span>';
                return;
            }

            const button = document.getElementById('generate-button');
            const buttonText = document.getElementById('generate-text');
            const spinner = document.getElementById('creative-loading-spinner');
            const outputDiv = document.getElementById('ai-output');
            const saveOptionsDiv = document.getElementById('save-options-creative');
            const saveStatusElement = document.getElementById('npc-save-status');
            
            // NEW: Hide image output area for this mode
            const imageOutputDiv = document.getElementById('ai-image-output');
            imageOutputDiv.classList.add('hidden');

            // Reset UI
            saveStatusElement.classList.add('hidden');
            saveOptionsDiv.classList.add('hidden');
            button.disabled = true;
            buttonText.textContent = 'Generating...';
            spinner.classList.remove('hidden');
            outputDiv.textContent = 'Generating creative idea...';
            lastGeneratedNpc = null; // Clear NPC data

            // --- Payload for Text Generation ---
            const systemPromptText = `You are a creative D&D Dungeon Master Assistant. The user will provide a prompt, and you should generate a creative and useful response based on it. This could be an NPC backstory, location description, quest hook, or piece of lore. Format the response with simple markdown for readability (bolding, bullet points).`;
            
            const textPayload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemPromptText }] },
                tools: [{ "google_search": {} }], // Enable search for broader context
            };

            try {
                const response = await fetchWithExponentialBackoff(API_URL + apiKey, textPayload);
                const result = await response.json();
                const resultText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!resultText) {
                    throw new Error('Received an empty or invalid response from the model.');
                }
                
                outputDiv.textContent = resultText;
                saveOptionsDiv.classList.remove('hidden'); // Show save buttons

            } catch (error) {
                console.error("Creative Generation Error:", error);
                outputDiv.textContent = `Error: Could not generate idea. ${error.message}`;
            } finally {
                button.disabled = false;
                buttonText.textContent = 'Generate Idea';
                spinner.classList.add('hidden');
            }
        }
        // --- END: FIX FOR ReferenceError ---


        // --- REWRITTEN: MODE 3: Settlement Generation (with Image) ---
        window.generateSettlement = async function() {
            const type = document.getElementById('settlement-type').value;
            const vibe = document.getElementById('settlement-vibe').value.trim();
            
            if (!vibe) {
                document.getElementById('ai-output').innerHTML = '<span class="text-red-400">Please enter a vibe or description for the settlement.</span>';
                return;
            }

            const button = document.getElementById('generate-settlement-button');
            const buttonText = document.getElementById('generate-settlement-text');
            const spinner = document.getElementById('settlement-loading-spinner');
            const outputDiv = document.getElementById('ai-output');
            const saveOptionsDiv = document.getElementById('save-options-creative');
            const saveStatusElement = document.getElementById('npc-save-status');
            
            // NEW Image Elements
            const imageOutputDiv = document.getElementById('ai-image-output');
            const generatedImage = document.getElementById('generated-image');
            const imageLoadingStatus = document.getElementById('image-loading-status');

            // Reset UI
            saveStatusElement.classList.add('hidden');
            saveOptionsDiv.classList.add('hidden');
            button.disabled = true;
            buttonText.textContent = 'Generating...';
            spinner.classList.remove('hidden');
            
            // Set loading states for both text and image
            outputDiv.textContent = 'Building your settlement details...';
            imageOutputDiv.classList.remove('hidden');
            generatedImage.src = '';
            generatedImage.classList.add('hidden'); // Hide img tag until src is set
            imageLoadingStatus.textContent = 'Generating settlement image (this may take a moment)...';
            imageLoadingStatus.classList.remove('hidden');
            
            lastGeneratedNpc = null; 

            // --- Payload for Text Generation ---
            const systemPromptText = `You are a D&D Dungeon Master Assistant specializing in rapid world-building. Generate a settlement based on the user's requested type and vibe.

Format the response strictly with markdown for readability. You MUST include all requested sections. Use bullet points for lists.
                
**Name:** [Generate a creative name]
**Type:** [The user's requested type, e.g., Village, Town]
**Description:** [A 1-2 sentence summary based on the user's vibe]

---

**Lore:**
* [1-2 bullet points on the settlement's brief history or a local legend.]

---

**Politics:**
* **[Who's in Charge]:** [Brief 1-sentence description of the ruling power (e.g., 'Mayor Grom, a grizzled ex-adventurer').]
* **[Local Tension]:** [Brief 1-sentence description of a political issue (e.g., 'Tensions are high with the local miners guild over taxes.').]

---

**Key Areas (3-4):**
* **[Area Name]:** [Brief description of the location (e.g., tavern, shop, ruin).]

---

**NPCs & Quests (2-3):**
* **[NPC Name] ([Occupation]) at [Location]:** [1-sentence personality trait].
* **Quick Quest:** [A very simple 1-sentence quest hook related to this NPC.]
`;
            
            const userQuery = `Generate a ${type} with the vibe: ${vibe}.`;
            const textPayload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPromptText }] },
                tools: [{ "google_search": {} }],
            };

            // --- Prompt for Image Generation ---
            const imagePrompt = `A high-quality, atmospheric, bird's-eye-view concept art of a fantasy ${type} that feels like a ${vibe}. No text or labels. D&D, fantasy art style.`;

            // --- Run API calls in parallel ---
            try {
                const [textResult, imageResult] = await Promise.allSettled([
                    fetchSettlementText(textPayload),
                    fetchSettlementImage(imagePrompt)
                ]);

                // Handle Text Result
                if (textResult.status === 'fulfilled') {
                    outputDiv.textContent = textResult.value;
                    saveOptionsDiv.classList.remove('hidden'); // Show save buttons
                } else {
                    console.error("Settlement Text Generation Error:", textResult.reason);
                    outputDiv.textContent = `Error: Could not generate settlement text. ${textResult.reason.message}`;
                }

                // Handle Image Result
                if (imageResult.status === 'fulfilled') {
                    generatedImage.src = imageResult.value;
                    generatedImage.classList.remove('hidden');
                    imageLoadingStatus.textContent = ''; // Clear loading text
                    imageLoadingStatus.classList.add('hidden');
                } else {
                    console.error("Settlement Image Generation Error:", imageResult.reason);
                    imageLoadingStatus.textContent = `Error generating image: ${imageResult.reason.message}`;
                    imageLoadingStatus.classList.remove('hidden');
                    generatedImage.classList.add('hidden'); // Keep img tag hidden
                }

            } catch (error) {
                // This catch is for Promise.allSettled itself, which is unlikely
                console.error("Settlement Generation Error:", error);
                outputDiv.textContent = `Error: Could not generate settlement. ${error.message}`;
                imageLoadingStatus.textContent = `Image generation failed.`;
            } finally {
                button.disabled = false;
                buttonText.textContent = 'Generate Settlement';
                spinner.classList.add('hidden');
            }
        }

        // --- NEW Helper: Fetch Settlement Text ---
        async function fetchSettlementText(payload) {
            const response = await fetchWithExponentialBackoff(API_URL + apiKey, payload);
            const result = await response.json();
            const resultText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!resultText) {
                throw new Error('Invalid text response from API.');
            }
            return resultText;
        }
        
        // --- NEW Helper: Fetch Settlement Image ---
        async function fetchSettlementImage(prompt) {
            const payload = {
                instances: { prompt: prompt },
                parameters: { "sampleCount": 1 }
            };
            
            // Use the new IMAGE_API_URL constant
            const response = await fetchWithExponentialBackoff(IMAGE_API_URL + apiKey, payload);
            const result = await response.json();
            
            if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
            } else {
                console.warn("Image API response missing data:", result);
                throw new Error('Invalid or empty image response from API.');
            }
        }


        // --- RENAMED: MODE 4: Monster Stat Block Generation ---
        window.generateMonsterStatblock = async function() {
            const name = document.getElementById('monster-name').value.trim();
            const cr = document.getElementById('monster-cr').value.trim();

            if (!name || !cr) {
                document.getElementById('monster-status-message').textContent = "Please provide both a Monster Name and a CR.";
                document.getElementById('monster-status-message').classList.remove('hidden');
                return;
            }

            const button = document.getElementById('generate-monster-button');
            const buttonText = document.getElementById('generate-monster-text');
            const spinner = document.getElementById('monster-loading-spinner');
            const outputDiv = document.getElementById('monster-output');
            const saveStatusElement = document.getElementById('monster-save-status');
            const saveOptionsDiv = document.getElementById('save-options-monster');

            document.getElementById('monster-status-message').classList.add('hidden');
            saveStatusElement.classList.add('hidden');
            saveOptionsDiv.classList.add('hidden');

            button.disabled = true;
            buttonText.textContent = 'Generating...';
            spinner.classList.remove('hidden');
            outputDiv.innerHTML = 'Generating full monster stat block...';
            lastGeneratedMonster = null; // Reset

            const systemPrompt = `You are an expert D&D 5e Monster Designer. Your task is to generate a complete and balanced monster stat block based on the user's provided name and Challenge Rating (CR). You MUST return the data exactly according to the JSON schema provided. Ensure abilities, actions, and stats are appropriate for the requested CR.`;
            const userQuery = `Generate a full monster stat block for a "${name}" with a Challenge Rating (CR) of ${cr}.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: monsterSchema
                },
            };

            try {
                const response = await fetchWithExponentialBackoff(API_URL + apiKey, payload);
                const result = await response.json();
                const jsonString = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (!jsonString) {
                    throw new Error("Received an empty or invalid response from the model.");
                }

                const stats = JSON.parse(jsonString);
                lastGeneratedMonster = stats; // Store the successful result

                // Render the stat block
                outputDiv.innerHTML = renderMonsterStatblock(stats);
                saveOptionsDiv.classList.remove('hidden');

            } catch (error) {
                console.error("Monster Generation Error:", error);
                outputDiv.innerHTML = `<span class="text-red-400">Error generating monster: ${error.message}. Please try again.</span>`;
            } finally {
                button.disabled = false;
                buttonText.textContent = 'Generate Monster';
                spinner.classList.add('hidden');
            }
        }

        // --- NEW: Monster Stat Block HTML Renderer ---
        function renderMonsterStatblock(stats) {
            const getMod = (score) => Math.floor((score - 10) / 2);
            const modSign = (score) => getMod(score) >= 0 ? `+${getMod(score)}` : getMod(score);

            const abilities = stats.abilities || [];
            const actions = stats.actions || [];
            const legendaryActions = stats.legendary_actions || [];

            const renderSection = (title, items) => {
                if (!items || items.length === 0) return '';
                return `
                    <h4 class="text-lg font-bold text-indigo-300 mt-2 pb-1 border-b border-indigo-400">${title}</h4>
                    ${items.map(item => `
                        <p class="mt-2 text-sm">
                            <strong class="text-white">${item.name}.</strong> 
                            <span class="text-gray-300">${item.description}</span>
                        </p>
                    `).join('')}
                `;
            };

            const renderList = (items) => {
                if (!items || items.length === 0) return '‚Äî';
                return items.join(', ');
            };

            return `
                <div class="stat-block bg-gray-800 p-4 rounded-lg border border-indigo-500">
                    <h3 class="text-2xl font-bold text-indigo-300 mb-1">${stats.name}</h3>
                    <p class="text-sm italic text-gray-400">${stats.size} ${stats.type}, ${stats.alignment}</p>
                    
                    <div class="h-px bg-indigo-400 my-2"></div>

                    <p class="text-sm"><strong class="text-white">Armor Class:</strong> ${stats.armor_class} (${stats.ac_type || 'N/A'})</p>
                    <p class="text-sm"><strong class="text-white">Hit Points:</strong> ${stats.hit_points} (${stats.hit_dice})</p>
                    <p class="text-sm"><strong class="text-white">Speed:</strong> ${stats.speed}</p>

                    <div class="h-px bg-indigo-400 my-2"></div>

                    <div class="grid grid-cols-6 gap-2 text-center my-3">
                        ${['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'].map(ability => `
                            <div class="text-sm">
                                <strong class="text-white">${ability}</strong>
                                <div>${stats.ability_scores[ability]} (${modSign(stats.ability_scores[ability])})</div>
                            </div>
                        `).join('')}
                    </div>

                    <div class="h-px bg-indigo-400 my-2"></div>

                    <p class="text-sm"><strong class="text-white">Saving Throws:</strong> ${renderList(stats.saving_throws)}</p>
                    <p class="text-sm"><strong class="text-white">Skills:</strong> ${renderList(stats.skills)}</p>
                    <p class="text-sm"><strong class="text-white">Damage Vulnerabilities:</strong> ${renderList(stats.damage_vulnerabilities)}</p>
                    <p class="text-sm"><strong class="text-white">Damage Resistances:</strong> ${renderList(stats.damage_resistances)}</p>
                    <p class="text-sm"><strong class="text-white">Damage Immunities:</strong> ${renderList(stats.damage_immunities)}</p>
                    <p class="text-sm"><strong class="text-white">Condition Immunities:</strong> ${renderList(stats.condition_immunities)}</p>
                    <p class="text-sm"><strong class="text-white">Senses:</strong> ${stats.senses}</p>
                    <p class="text-sm"><strong class="text-white">Languages:</strong> ${stats.languages}</p>
                    <p class="text-sm"><strong class="text-white">Challenge:</strong> ${stats.challenge_rating} (${stats.xp} XP)</p>

                    ${renderSection('Abilities', abilities)}
                    ${renderSection('Actions', actions)}
                    ${renderSection('Legendary Actions', legendaryActions)}
                </div>
            `;
        }

        // --- NEW: Save functions for generated monster ---
        window.addMonsterToStatblocks = async function () {
            const statusElement = document.getElementById('monster-save-status');
            if (!window.isAuthReady || !window.db) {
                statusElement.textContent = 'Database not ready.';
                statusElement.classList.remove('hidden');
                return;
            }
            if (!lastGeneratedMonster) {
                statusElement.textContent = 'No monster data to save.';
                statusElement.classList.remove('hidden');
                return;
            }

            const monster = lastGeneratedMonster;
            
            // Try to find the 'to hit' bonus and damage from the first action
            let toHit = 0;
            let dmg = 'N/A';
            if (monster.actions && monster.actions.length > 0) {
                const firstAction = monster.actions[0].description;
                // Regex to find +N to hit
                const hitMatch = firstAction.match(/(\+|\-)\d+\s+to hit/);
                // Regex to find simple damage dice like 1d8, 2d6+3, etc.
                // REMOVED: const dmgMatch = firstAction.match(/\d+d\d+(\s*(\+|\-)\s*\d+)?/); 
                
                if (hitMatch) toHit = parseInt(hitMatch[0].replace(' to hit', ''), 10);
                // REMOVED: if (dmgMatch) dmg = dmgMatch[0];

                // --- MODIFIED: Format all actions into an HTML string ---
                dmg = monster.actions.map(action => {
                    // Added block and margin-top for better spacing in the statblock card
                    return `<span class='block mt-1'><strong>${action.name}:</strong> ${action.description}</span>`;
                }).join('');
                // --- END MODIFICATION ---

            }
            
            // Get initiative bonus (DEX mod)
            const initMod = Math.floor((monster.ability_scores.DEX - 10) / 2);

            statusElement.textContent = `Saving ${monster.name} to Statblocks...`;
            statusElement.classList.remove('hidden', 'text-red-400', 'text-green-400');
            statusElement.classList.add('text-yellow-400');

            try {
                await window.addDoc(getStatblocksCollectionRef(), {
                    name: monster.name,
                    hp: monster.hit_points,
                    ac: monster.armor_class,
                    toHit: toHit,
                    initMod: initMod,
                    dmg: dmg,
                    timestamp: new Date().toISOString()
                });
                
                statusElement.textContent = `${monster.name} added to Statblocks!`;
                statusElement.classList.remove('text-yellow-400');
                statusElement.classList.add('text-green-400');
            } catch (error) {
                console.error("Error saving monster to statblocks: ", error);
                statusElement.textContent = `Error saving statblock: ${error.message}`;
                statusElement.classList.add('text-red-400');
            }
        }

        window.saveMonsterToNotes = async function() {
            const statusElement = document.getElementById('monster-save-status');
            const outputDiv = document.getElementById('monster-output');
            const content = outputDiv.innerHTML; // Save the rendered HTML

            if (!lastGeneratedMonster) {
                statusElement.textContent = 'No monster data to save.';
                statusElement.classList.remove('hidden');
                return;
            }
            if (!window.isAuthReady || !window.db) {
                statusElement.textContent = 'Database not ready.';
                statusElement.classList.remove('hidden');
                return;
            }
            
            statusElement.textContent = `Saving ${lastGeneratedMonster.name} to Enemy Notes...`;
            statusElement.classList.remove('hidden', 'text-red-400', 'text-green-400');
            statusElement.classList.add('text-yellow-400');

            const newNote = {
                id: crypto.randomUUID(),
                title: `${lastGeneratedMonster.name} (CR ${lastGeneratedMonster.challenge_rating})`,
                content: content, // Save the pre-formatted HTML
                timestamp: new Date().toISOString()
            };
            
            structuredNotes['enemyNotes'].unshift(newNote); // Add to beginning of enemyNotes
            await saveStructuredNotes('enemyNotes', structuredNotes['enemyNotes']);

            statusElement.textContent = `${lastGeneratedMonster.name} saved to Enemy Notes!`;
            statusElement.classList.remove('text-yellow-400');
            statusElement.classList.add('text-green-400');

            // Optionally switch to the notes tab
            switchTab('notes');
            switchSubTab('enemyNotes');
        }


        // --- NEW: Unified Saving Function ---
        
        // Helper to generate a good title for the collapsible note
        function generateTitleFromContent(content) {
            // Priority 1: Look for the bolded name in the generated format
            const nameMatch = content.match(/\*\*Name:\*\*\s*(.*?)\n/);
            if (nameMatch) {
                return nameMatch[1].trim() || 'Untitled Generated Note';
            }
            // Priority 2: Use the first 50 characters
            const shortTitle = content.substring(0, 50).trim().replace(/[\n\r]/g, ' ');
            return shortTitle + (content.length > 50 ? '...' : '');
        }

        window.saveGeneratedContent = async function(destinationTab) {
            const outputDiv = document.getElementById('ai-output');
            // FIX: Also check loot-output if that tab is active
            let idea = outputDiv.textContent.trim();
            
            if (currentTab === 'loot') {
                const lootDiv = document.getElementById('loot-output');
                idea = lootDiv.textContent.trim();
            }

            const statusElement = document.getElementById('notes-status');

            if (idea === 'Results will appear here.' || idea === 'Loot drops will appear here.' || idea.startsWith('Error:')) {
                statusElement.textContent = 'Nothing valid to save.';
                return;
            }

            if (!window.isAuthReady || !window.db) {
                statusElement.textContent = 'Database not ready. Please wait for authentication.';
                return;
            }

            const title = generateTitleFromContent(idea);

            const newNote = {
                id: crypto.randomUUID(),
                title: title,
                content: idea,
                timestamp: new Date().toISOString()
            };
            
            structuredNotes[destinationTab].unshift(newNote); // Add to beginning
            
            // Save the updated array
            await saveStructuredNotes(destinationTab, structuredNotes[destinationTab]);

            // Switch and display feedback
            switchTab('notes');
            switchSubTab(destinationTab);
            statusElement.textContent = `New note saved and placed in the collapsible list for '${destinationTab}'!`;
        }


        // --- Shared API Helper ---
        async function fetchWithExponentialBackoff(apiUrl, payload) {
            const maxAttempts = 5;
            
            // --- FIX: Use user's saved key if available, otherwise fallback to hardcoded ---
            const activeKey = userApiKey || apiKey;
            
            // Use the key, ensuring it's appended correctly.
            const urlWithKey = apiUrl.endsWith('?key=') ? apiUrl + activeKey : apiUrl;

            for (let attempts = 0; attempts < maxAttempts; attempts++) {
                try {
                    const response = await fetch(urlWithKey, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429) {
                        const delay = Math.pow(2, attempts) * 1000;
                        console.warn(`API rate limit hit. Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }

                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error("API Error Body:", errorBody);
                        throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
                    }
                    return response;
                } catch (error) {
                    console.error(`Attempt ${attempts + 1} failed:`, error);
                    if (attempts === maxAttempts - 1) throw error;
                    const delay = Math.pow(2, attempts) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }


        // --- Combat Tracker Logic (Includes Dice Roller) ---

        function renderCombatants() {
            const list = document.getElementById('initiative-list');
            list.innerHTML = '';
            
            if (combatants.length === 0) {
                list.innerHTML = '<p class="text-center text-gray-500 pt-8">Add your players and monsters to start tracking combat!</p>';
                currentTurnIndex = -1;
                lastRoll = 0;
                const rollDisplay = document.getElementById('last-roll-display');
                if(rollDisplay) rollDisplay.textContent = '?';
                const assignButton = document.getElementById('assign-roll-button');
                if(assignButton) assignButton.disabled = true;
                return;
            }

            combatants.forEach((c, index) => {
                const isActive = index === currentTurnIndex;
                if (c.initModifier === undefined) {
                    c.initModifier = c.init > 10 ? 0 : c.init;
                }
                // Ensure AC has a default value if not set
                if (c.ac === undefined) {
                    c.ac = 0;
                }
                const initModifierDisplay = c.initModifier >= 0 ? `+${c.initModifier}` : c.initModifier.toString();


                const element = document.createElement('div');
                // Updated class list for slightly more horizontal space management
                element.className = `flex items-center space-x-1 p-3 rounded-lg transition duration-200 ${isActive ? 'bg-indigo-700 glow-shadow' : 'bg-gray-700'}`;
                
                element.innerHTML = `
                    <div class="text-lg font-bold w-6 text-center ${isActive ? 'text-white' : 'text-indigo-400'}">${c.init}</div>
                    <div class="flex-1 min-w-[50px]">
                        <div class="font-semibold text-sm truncate ${isActive ? 'text-white' : 'text-gray-200'}">${c.name}</div>
                        <div class="text-xs">
                            <span class="${c.currentHp <= 0 ? 'text-red-400' : 'text-green-400'}">HP: ${c.currentHp} / ${c.maxHp}</span> 
                            <span class="text-blue-300 ml-1">AC: ${c.ac}</span>
                            <span class="text-gray-400"> (Mod: ${initModifierDisplay})</span>
                        </div>
                    </div>
                    <!-- NEW HP MANAGEMENT CONTROLS -->
                    <div class="flex space-x-1 items-center">
                        <input type="number" placeholder="Amt" id="damage-input-${index}" class="w-12 p-1 rounded-lg input-style text-center text-xs" />
                        <button onclick="applyHpChange(${index}, 'heal')" class="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-2 rounded-lg transition duration-300">Heal</button>
                        <button onclick="applyHpChange(${index}, 'damage')" class="bg-red-500 hover:bg-red-600 text-white text-xs font-bold py-1 px-2 rounded-lg transition duration-300">DMG</button>
                    </div>
                    <button onclick="removeCombatant(${index})" class="bg-gray-500 hover:bg-gray-600 text-white text-xs font-bold py-1 px-2 rounded-lg transition duration-300">Rem</button>
                `;
                list.appendChild(element);
            });
            populateCombatantSelector();
        }

        // New consolidated function for HP changes
        window.applyHpChange = async function(index, type) { 
            const damageInput = document.getElementById(`damage-input-${index}`);
            let value = parseInt(damageInput.value, 10);

            if (isNaN(value) || value <= 0) { // Value must be positive now
                damageInput.value = '';
                return;
            }

            // --- FIX: Calculate the new HP based on the input value ---
            let newHp = combatants[index].currentHp;
            if (type === 'damage') {
                newHp -= value;
            } else if (type === 'heal') {
                newHp += value;
            }
            // Clamp HP between 0 and maxHp
            newHp = Math.max(0, Math.min(newHp, combatants[index].maxHp));
            // --- End Fix ---

            // REFACTORED: Update the specific document in Firestore
            const combatantDocRef = window.doc(getCombatantsCollectionRef(), combatants[index].id);
            try {
                await window.updateDoc(combatantDocRef, {
                    currentHp: newHp // Save the *newly calculated* HP
                });
            } catch (error) {
                console.error("Error updating HP:", error);
            }

            damageInput.value = '';
            // No longer need to call renderCombatants() or saveCombatantsToFirestore()
            // The onSnapshot listener will detect the change and re-render.
        }

        /**
         * REFACTORED: This function now creates a new document in the combatants collection.
         */
        window.addCombatant = async function() {
            const nameInput = document.getElementById('combatant-name');
            const initInput = document.getElementById('combatant-init');
            const acInput = document.getElementById('combatant-ac'); // NEW: AC Input
            const hpInput = document.getElementById('combatant-hp');

            const name = nameInput.value.trim();
            const initValue = parseInt(initInput.value, 10) || 0; 
            const ac = parseInt(acInput.value, 10) || 0; // Default to 0 if empty
            const hp = parseInt(hpInput.value, 10) || 0; // Default to 0 if empty

            // Updated validation: Only name is strictly required.
            if (!name) {
                alert("Please enter a name for the combatant.");
                return;
            }

            // REFACTORED: Create a new document in Firestore instead of pushing locally
            try {
                await window.addDoc(getCombatantsCollectionRef(), { 
                    name, 
                    init: initValue, 
                    maxHp: hp, 
                    currentHp: hp, 
                    initModifier: initValue,
                    ac: ac // NEW: Store AC
                });

                // ONLY clear inputs on success
                nameInput.value = '';
                initInput.value = '';
                acInput.value = ''; 
                hpInput.value = '';
            } catch (error) {
                console.error("Error adding combatant:", error);
                alert("Failed to add combatant. Check your connection or login status.");
            }
        }

        /**
         * REFACTORED: This button now just resets the turn index to 0.
         * The sorting is handled automatically by the Firestore listener.
         */
        window.sortInitiative = function() {
            currentTurnIndex = 0;
            // We just need to save the *state*
            saveCombatStateToFirestore();
        }

        // Removed old applyDamage, replaced by applyHpChange

        /**
         * REFACTORED: This function now deletes a document from the collection.
         */
        window.removeCombatant = async function(index) {
            if (!combatants[index] || !combatants[index].id) {
                console.error("Cannot remove combatant, missing ID.");
                return;
            }
            
            const combatantDocRef = window.doc(getCombatantsCollectionRef(), combatants[index].id);
            try {
                await window.deleteDoc(combatantDocRef);
            } catch (error) {
                console.error("Error removing combatant:", error);
            }
            
            // The onSnapshot listener will handle re-rendering.
            // We just need to check if the turn index is now out of bounds.
            if (currentTurnIndex >= combatants.length - 1) {
                currentTurnIndex = combatants.length > 1 ? combatants.length - 2 : -1;
                saveCombatStateToFirestore();
            }
        }

        /**
         * REFACTORED: This function now only updates the turn index.
         */
        window.nextTurn = function() {
            if (combatants.length === 0) {
                currentTurnIndex = -1;
                return;
            }
            currentTurnIndex = (currentTurnIndex + 1) % combatants.length;
            // Save the new state
            saveCombatStateToFirestore();
        }
        
        /**
         * REFACTORED: This function now uses a Write Batch to delete all docs in the collection.
         */
        window.clearCombat = async function() {
            if (!window.isAuthReady || !window.db) return;
            
            try {
                const batch = window.writeBatch(window.db);
                
                // Get all combatant docs
                combatants.forEach(c => {
                    const docRef = window.doc(getCombatantsCollectionRef(), c.id);
                    batch.delete(docRef);
                });
                
                // Also delete the state doc
                batch.delete(getCombatStateDocRef());

                await batch.commit();

                // Listeners will fire and clear the UI
            } catch (error) {
                console.error("Error clearing combat:", error);
            }
        }

        // --- NEW: Custom Dice Roller for Statblocks Tab ---
        window.rollCustomDice = function() {
            const numDiceInput = document.getElementById('dice-num');
            const diceTypeInput = document.getElementById('dice-type');
            const modInput = document.getElementById('dice-mod');
            const resultDisplay = document.getElementById('dice-roll-result');
            const detailsDisplay = document.getElementById('dice-roll-details');

            const numDice = parseInt(numDiceInput.value, 10) || 1;
            const diceType = parseInt(diceTypeInput.value, 10) || 20;
            const modifier = parseInt(modInput.value, 10) || 0;

            if (numDice <= 0) {
                resultDisplay.textContent = 'Error';
                detailsDisplay.textContent = 'Number of dice must be 1 or more.';
                return;
            }

            let totalRoll = 0;
            const rolls = [];
            for (let i = 0; i < numDice; i++) {
                const roll = Math.floor(Math.random() * diceType) + 1;
                rolls.push(roll);
                totalRoll += roll;
            }

            const finalTotal = totalRoll + modifier;
            const modString = modifier > 0 ? `+${modifier}` : (modifier < 0 ? `${modifier}` : '');

            resultDisplay.textContent = `Total: ${finalTotal}`;
            
            // Show modifier only if it's not zero
            if (modifier !== 0) {
                detailsDisplay.textContent = `Rolls: [${rolls.join(', ')}] (Mod: ${modString})`;
            } else {
                detailsDisplay.textContent = `Rolls: [${rolls.join(', ')}]`;
            }
        }

        window.rollD20 = function() {
            lastRoll = Math.floor(Math.random() * 20) + 1;
            document.getElementById('last-roll-display').textContent = lastRoll;
            document.getElementById('assign-roll-button').disabled = combatants.length === 0;
        }

        function populateCombatantSelector() {
            const selector = document.getElementById('combatant-selector');
            selector.innerHTML = '<option value="" disabled selected>Select Target</option>';
            
            combatants.forEach((c, index) => {
                const option = document.createElement('option');
                option.value = index;
                const mod = c.initModifier !== undefined ? c.initModifier : 0;
                const modDisplay = mod >= 0 ? `+${mod}` : mod.toString();

                option.textContent = `${c.name} (Mod: ${modDisplay})`;
                selector.appendChild(option);
            });
            document.getElementById('assign-roll-button').disabled = combatants.length === 0 || lastRoll === 0;
        }

        /**
         * REFACTORED: This function now updates a specific document's initiative score.
         */
        window.assignInitiativeRoll = async function() {
            const selector = document.getElementById('combatant-selector');
            const selectedIndex = parseInt(selector.value, 10);
            
            if (isNaN(selectedIndex) || selectedIndex < 0 || lastRoll === 0) {
                console.error("No combatant selected or no roll made to assign.");
                return;
            }
            
            const modifier = combatants[selectedIndex].initModifier || 0; 

            const newInitiative = lastRoll + modifier;
            
            // REFACTORED: Update the specific doc in Firestore
            const combatantDocRef = window.doc(getCombatantsCollectionRef(), combatants[selectedIndex].id);
            try {
                await window.updateDoc(combatantDocRef, {
                    init: newInitiative
                });
            } catch (error) {
                console.error("Error assigning initiative:", error);
            }
            
            lastRoll = 0;
            document.getElementById('last-roll-display').textContent = '?';
            selector.value = '';
            document.getElementById('assign-roll-button').disabled = true;

            // No longer need to call render/save. The 'orderBy' listener will
            // automatically re-sort and re-render the list.
        }

        // Initial render for combat tracker (before data loads)
        document.addEventListener('DOMContentLoaded', () => {
            // Fix: Check for element existence before setting textContent
            const appIdDisplay = document.getElementById('app-id-display');
            if (appIdDisplay && !firebaseConfig) {
                appIdDisplay.textContent = 'Game ID: N/A (No Firebase Config)';
            }
            
            renderCombatants(); 
            populateCombatantSelector();
            switchTab(currentTab);
            
            // --- NEW: Load saved key on startup ---
            const status = document.getElementById('api-key-status');
            if (userApiKey && status) {
                status.textContent = "Status: Key loaded from local storage.";
                status.className = "mt-2 text-xs text-green-400";
            }
        });

        // --- NEW FUNCTION: Generate Loot ---
        window.generateLoot = async function() {
            const level = document.getElementById('loot-level').value.trim();
            const type = document.getElementById('loot-type').value;
            const outputDiv = document.getElementById('loot-output');
            const spinner = document.getElementById('loot-loading-spinner');
            const button = document.getElementById('generate-loot-button');
            const buttonText = document.getElementById('generate-loot-text');

            if (!level) {
                outputDiv.innerHTML = '<span class="text-red-400">Please enter a level or CR.</span>';
                return;
            }

            button.disabled = true;
            buttonText.textContent = 'Generating...';
            spinner.classList.remove('hidden');
            outputDiv.textContent = 'Rolling for treasure...';

            const systemPrompt = `You are a D&D 5e Loot Generator. Generate a balanced loot hoard or drop based on the input. Return the result in clean Markdown format using bullet points.
            
            **Format:**
            **Name:** [Creative name for the hoard, e.g., "Goblin Stash"]
            
            **Coins:**
            * [Amount] [Coin Type]
            
            **Gems & Art (if any):**
            * [Item description] (Value)
            
            **Items:**
            * [Item Name]: [Brief description]
            `;
            
            const userQuery = `Generate a ${type} loot drop for a Level/CR ${level} encounter.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] }
            };

            try {
                const response = await fetchWithExponentialBackoff(API_URL + apiKey, payload);
                const result = await response.json();
                const resultText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (resultText) {
                    outputDiv.textContent = resultText;
                } else {
                    throw new Error("No text returned");
                }
            } catch (error) {
                console.error("Loot Generation Error:", error);
                outputDiv.innerHTML = `<span class="text-red-400">Error generating loot: ${error.message}</span>`;
            } finally {
                button.disabled = false;
                buttonText.textContent = 'Generate Loot';
                spinner.classList.add('hidden');
            }
        }

        // --- NEW FUNCTION: Soundboard Synthesizer (Web Audio API) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Helper for chords/sequences
        function playNote(freq, startTime, duration, type = 'sine', vol = 0.3) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, startTime);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(vol, startTime);
            gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        // --- NEW HELPER: Drum Synthesizer ---
        function playDrum(type, time) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'kick') {
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(0.5, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.start(time);
                osc.stop(time + 0.5);
            } else if (type === 'snare') {
                // Filtered noise for snare/clash
                const noise = audioCtx.createBufferSource();
                noise.buffer = noiseBuffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                noise.connect(filter);
                filter.connect(gain);
                gain.gain.setValueAtTime(0.4, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                noise.start(time);
                noise.stop(time + 0.2);
            } else if (type === 'hihat') {
                const noise = audioCtx.createBufferSource();
                noise.buffer = noiseBuffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 5000;
                noise.connect(filter);
                filter.connect(gain);
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                noise.start(time);
                noise.stop(time + 0.05);
            } else if (type === 'tom') {
                osc.frequency.setValueAtTime(100, time);
                osc.frequency.exponentialRampToValueAtTime(50, time + 0.3);
                gain.gain.setValueAtTime(0.4, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
                osc.start(time);
                osc.stop(time + 0.3);
            }
        }

        // --- NEW HELPER: Lute Synthesizer (for Tavern Music) ---
        function playLute(freq, startTime, duration) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter(); // Lowpass for warm string sound

            osc.type = 'sawtooth'; // Sawtooth gives a string-like buzzing quality
            osc.frequency.setValueAtTime(freq, startTime);
            
            // Filter down the harshness
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, startTime);

            // Envelope: Pluck attack, long decay
            gain.gain.setValueAtTime(0.1, startTime); // Keep volume background-level
            gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        // --- NEW HELPER: Accordion Synthesizer (for Sea Shanty) ---
        function playAccordion(freq, startTime, duration, vol = 0.15) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            // Reedy sound: Sawtooth
            osc.type = 'sawtooth'; 
            osc.frequency.setValueAtTime(freq, startTime);

            // Filter to take off the harsh digital edge but keep it bright
            filter.type = 'lowpass';
            filter.frequency.value = 2500;

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            // Envelope: Swell in and out (simulating bellows)
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(vol, startTime + 0.1); // Attack
            gain.gain.setValueAtTime(vol, startTime + duration - 0.1); // Sustain
            gain.gain.linearRampToValueAtTime(0, startTime + duration); // Release

            osc.start(startTime);
            osc.stop(startTime + duration);
        }

        window.playTone = function(type) {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            switch (type) {
                case 'success':
                    // High pitch "ding"
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523.25, now); // C5
                    osc.frequency.exponentialRampToValueAtTime(1046.5, now + 0.1); // C6
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;
                
                case 'critical':
                    // Fanfare triplet
                    playNote(523.25, now, 0.1); // C5
                    playNote(659.25, now + 0.1, 0.1); // E5
                    playNote(783.99, now + 0.2, 0.4); // G5
                    break;

                case 'fail':
                    // Low "womp"
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                    break;

                case 'combat_start':
                    // Aggressive pulse
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(110, now); // A2
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.setValueAtTime(0, now + 0.1);
                    gainNode.gain.setValueAtTime(0.3, now + 0.2);
                    gainNode.gain.setValueAtTime(0, now + 0.3);
                    gainNode.gain.setValueAtTime(0.3, now + 0.4);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.8);
                    osc.start(now);
                    osc.stop(now + 0.8);
                    break;

                case 'spell':
                    // Magic sweep
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(2000, now + 1);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 1);
                    osc.start(now);
                    osc.stop(now + 1);
                    break;

                case 'mystery':
                    // Eerie wobble
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(300, now);
                    // LFO effect simulation via frequency ramp modulation manually isn't easy here, just a slow slide
                    osc.frequency.linearRampToValueAtTime(290, now + 1);
                    osc.frequency.linearRampToValueAtTime(310, now + 2);
                    gainNode.gain.setValueAtTime(0.1, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 3);
                    osc.start(now);
                    osc.stop(now + 3);
                    break;

                case 'rest':
                    // Major chord pad
                    playNote(261.63, now, 2, 'sine', 0.1); // C4
                    playNote(329.63, now, 2, 'sine', 0.1); // E4
                    playNote(392.00, now, 2, 'sine', 0.1); // G4
                    break;

                case 'trap':
                    // Sharp dissonance
                    playNote(440, now, 0.2, 'sawtooth', 0.2);
                    playNote(466, now, 0.2, 'sawtooth', 0.2); // Minor 2nd interval
                    break;

                case 'boss':
                    // Deep drone
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(55, now); // A1
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 2);
                    // Add a sub-oscillator
                    const subOsc = audioCtx.createOscillator();
                    const subGain = audioCtx.createGain();
                    subOsc.type = 'sine';
                    subOsc.frequency.setValueAtTime(27.5, now); // A0
                    subOsc.connect(subGain);
                    subGain.connect(audioCtx.destination);
                    subGain.gain.setValueAtTime(0.5, now);
                    subGain.gain.linearRampToValueAtTime(0, now + 2);
                    subOsc.start(now);
                    subOsc.stop(now + 2);
                    
                    osc.start(now);
                    osc.stop(now + 2);
                    break;
            }
        }

        // --- NEW: Ambience Loop Logic ---
        let currentAmbience = null;
        let activeNodes = []; // Track all active oscillators/intervals for the current loop

        // Create a noise buffer (essential for creating wind/rumble effects)
        function createNoiseBuffer() {
            const bufferSize = audioCtx.sampleRate * 2; // 2 seconds of noise
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            return buffer;
        }
        const noiseBuffer = createNoiseBuffer();

        window.toggleAmbience = function(type) {
            // Start Audio Context if needed
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const btn = document.getElementById(`ambience-${type}`);
            const status = document.getElementById('ambience-status');

            // If the same ambience is already playing, stop it.
            if (currentAmbience === type) {
                stopAmbience();
                status.textContent = '';
                return;
            }

            // Stop any other playing ambience first
            stopAmbience();

            // Start the new ambience
            currentAmbience = type;
            btn.classList.add('active-loop');
            status.textContent = `Playing: ${type.replace('_', ' ').toUpperCase()}...`;

            const now = audioCtx.currentTime;

            if (type === 'village') {
                // 1. Wind (Replaces Crowd Noise)
                const noise = audioCtx.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(400, now);
                // Modulate the filter frequency to simulate wind gusts
                const lfo = audioCtx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 0.1; // Very slow modulation
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 200; // Amount of modulation
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                
                const gain = audioCtx.createGain();
                gain.gain.value = 0.05; // Volume reduced from 0.15

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                
                noise.start(now);
                lfo.start(now);
                activeNodes.push(noise, lfo, gain);

                // 2. Market Sounds (Random Clinks/Wares)
                const waresInterval = setInterval(() => {
                    if (Math.random() > 0.6) {
                        // Metallic clink (coin/tool)
                        playNote(1500 + Math.random() * 500, audioCtx.currentTime, 0.05, 'triangle', 0.05);
                    }
                    if (Math.random() > 0.8) {
                        // Wood knock (cart/stall) - low pitch short sine
                        playNote(200 + Math.random() * 50, audioCtx.currentTime, 0.05, 'square', 0.05);
                    }
                }, 1500);
                activeNodes.push({ stop: () => clearInterval(waresInterval) });

                // 3. Upbeat Market Music (Fast Major Scale)
                // C Major: C5, D5, E5, F5, G5, A5, B5
                const scale = [523.25, 587.33, 659.25, 698.46, 783.99, 880.00, 987.77]; 
                let noteIndex = 0;
                
                const musicInterval = setInterval(() => {
                    const t = audioCtx.currentTime;
                    
                    // Play a steady rhythmic melody (High pitch "Flute" style)
                    if (Math.random() > 0.25) { 
                        const pitch = scale[Math.floor(Math.random() * scale.length)];
                        // Use playLute but with short duration for staccato feel
                        playLute(pitch, t, 0.15); 
                    }
                    
                    // Occasional root note anchor
                    if (noteIndex % 8 === 0) {
                        playLute(261.63, t, 0.3); // C4 Base
                    }
                    noteIndex++;
                }, 220); // Fast tempo ~136 BPM
                
                activeNodes.push({ stop: () => clearInterval(musicInterval) });
            }
            else if (type === 'city') {
                // 1. Urban Rumble (Brown Noise) - Simulates distant carts and heavy movement
                // Lowered frequency and volume to reduce "synth drone" feel
                const rumble = audioCtx.createBufferSource();
                rumble.buffer = noiseBuffer;
                rumble.loop = true;
                const rumbleFilter = audioCtx.createBiquadFilter();
                rumbleFilter.type = 'lowpass';
                rumbleFilter.frequency.value = 150; // Lowered from 200
                const rumbleGain = audioCtx.createGain();
                rumbleGain.gain.value = 0.1; // Reduced from 0.2
                
                rumble.connect(rumbleFilter);
                rumbleFilter.connect(rumbleGain);
                rumbleGain.connect(audioCtx.destination);
                rumble.start(now);
                activeNodes.push(rumble, rumbleGain);

                // Removed "General Hustle" (Bandpass noise) as it sounded too much like a constant synth.

                // 2. Industrial Sounds (Smithy/Construction)
                const industryInterval = setInterval(() => {
                    if (Math.random() > 0.6) {
                        // Hammer strike (Metal)
                        playNote(400 + Math.random() * 100, audioCtx.currentTime, 0.1, 'square', 0.05);
                    }
                    if (Math.random() > 0.8) {
                        // Cart thud (Low wood)
                        playNote(80, audioCtx.currentTime, 0.1, 'sine', 0.2);
                    }
                }, 2000);
                activeNodes.push({ stop: () => clearInterval(industryInterval) });

                // 3. Clock Tower / Temple Bell
                const bellInterval = setInterval(() => {
                    if (Math.random() > 0.85) {
                        const t = audioCtx.currentTime;
                        // Bell fundamental
                        playNote(220, t, 2.5, 'sine', 0.15); // Low A
                        // Bell harmonic to make it metallic
                        playNote(554, t, 1.5, 'sine', 0.05); // C# harmonic
                    }
                }, 8000); // Less frequent
                activeNodes.push({ stop: () => clearInterval(bellInterval) });

                // 4. Rhythmic City Music (Street Performer)
                // D Major Pentatonic: D, E, F#, A, B - Bright and busy
                const cityScale = [293.66, 329.63, 369.99, 440.00, 493.88, 587.33]; 
                let cityBeat = 0;
                
                const cityMusicInterval = setInterval(() => {
                    const t = audioCtx.currentTime;
                    
                    // Steady rhythmic pulse (every beat)
                    if (Math.random() > 0.2) {
                        const note = cityScale[Math.floor(Math.random() * cityScale.length)];
                        // Short crisp notes for a busy, walking rhythm
                        playLute(note, t, 0.15); 
                    }
                    
                    // Bass anchor on the 1 and 3 to keep the rhythm grounded
                    if (cityBeat % 4 === 0 || cityBeat % 4 === 2) {
                        playLute(146.83, t, 0.4); // Low D
                    }
                    
                    cityBeat++;
                }, 250); // Steady walking tempo (~120 BPM)
                
                activeNodes.push({ stop: () => clearInterval(cityMusicInterval) });
            }
            else if (type === 'ocean') {
                // --- SEA SHANTY MODE ---
                
                // 1. The Drone (Accordion Bass)
                // Low D (D2) continuous drone
                const drone = audioCtx.createOscillator();
                drone.type = 'sawtooth';
                drone.frequency.value = 73.42; // D2
                const droneFilter = audioCtx.createBiquadFilter();
                droneFilter.type = 'lowpass';
                droneFilter.frequency.value = 300; // Lowered cutoff to soften the hum
                const droneGain = audioCtx.createGain();
                droneGain.gain.value = 0.025; // Significantly reduced volume (was 0.1)
                
                // LFO for "breathing" bellows effect
                const lfo = audioCtx.createOscillator();
                lfo.frequency.value = 0.5; // Slow breath
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 0.01; // Reduced modulation depth
                lfo.connect(lfoGain);
                lfoGain.connect(droneGain.gain);
                lfo.start(now);

                drone.connect(droneFilter);
                droneFilter.connect(droneGain);
                droneGain.connect(audioCtx.destination);
                drone.start(now);
                
                activeNodes.push(drone, droneGain, lfo, lfoGain);

                // 2. The "Stomp-Clap" Beat & Melody
                // Scale: D Minor Pentatonic (D, F, G, A, C, D) - Folksy/Minor
                const shantyScale = [146.83, 174.61, 196.00, 220.00, 261.63, 293.66]; 
                let beat = 0;

                const shantyInterval = setInterval(() => {
                    const t = audioCtx.currentTime;
                    
                    // Rhythm Section (Heave-Ho!)
                    // Beat 1 & 3: Stomp (Kick)
                    if (beat % 2 === 0) {
                        playDrum('kick', t);
                        // Bass accordion note
                        playAccordion(146.83, t, 0.4, 0.2); // Low D
                    } 
                    // Beat 2 & 4: Clap (Snare)
                    else {
                        playDrum('snare', t); 
                        // Chord stab (D Minor: D+F+A)
                        playAccordion(293.66, t, 0.2, 0.05); // D4
                        playAccordion(349.23, t, 0.2, 0.05); // F4
                        playAccordion(440.00, t, 0.2, 0.05); // A4
                    }

                    // Procedural Melody (Accordion Lead)
                    // Play a note 70% of the time on the beat
                    if (Math.random() > 0.3) {
                        const note = shantyScale[Math.floor(Math.random() * shantyScale.length)];
                        const duration = Math.random() > 0.5 ? 0.4 : 0.9; // Short or Long notes
                        playAccordion(note, t, duration, 0.15);
                    }

                    beat++;
                }, 500); // 120 BPM (Marching speed)

                activeNodes.push({ stop: () => clearInterval(shantyInterval) });
            }
            else if (type === 'tavern') {
                // 1. Crowd Rumble (Lowpass Noise)
                const noise = audioCtx.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 150; // Deep rumble
                const gain = audioCtx.createGain();
                gain.gain.value = 0.25;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(now);
                activeNodes.push(noise, gain);

                // 2. Clinks (Bandpass noise bursts)
                const clinkInterval = setInterval(() => {
                    if (Math.random() > 0.6) {
                       playNote(1200, audioCtx.currentTime, 0.05, 'triangle', 0.05);
                    }
                }, 2500);
                activeNodes.push({ stop: () => clearInterval(clinkInterval) });

                // 3. Happy Tavern Music (Procedural Folk Melody)
                // Pentatonic Scale: C, D, E, G, A
                const scale = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25]; 
                let beat = 0;
                
                const musicInterval = setInterval(() => {
                    const t = audioCtx.currentTime;
                    // Bass note on downbeat (Root C3)
                    if (beat % 4 === 0) {
                        playLute(130.81, t, 0.8); 
                    }
                    
                    // Random melody walk on bouncy rhythm
                    if (Math.random() > 0.2) {
                        const noteIdx = Math.floor(Math.random() * scale.length);
                        // Slight offset to simulate picking
                        playLute(scale[noteIdx], t + 0.05, 0.4); 
                    }
                    beat++;
                }, 300); // ~100 BPM bouncy feel
                
                activeNodes.push({ stop: () => clearInterval(musicInterval) });
            }
            else if (type === 'battle_minor') {
                // 1. Tension Drone
                const osc = audioCtx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = 50;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                const gain = audioCtx.createGain();
                gain.gain.value = 0.1;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now);
                activeNodes.push(osc, gain);

                // 2. War Drum Rhythm (Simple March 4/4)
                // 100 BPM = 600ms per beat
                let beat = 0;
                const drumInterval = setInterval(() => {
                    const t = audioCtx.currentTime;
                    // Beat 1, 2, 3, 4
                    playDrum('kick', t); 
                    
                    // Accent on 1
                    if (beat % 4 === 0) {
                        playDrum('tom', t + 0.3); // Syncopated tom
                    }
                    beat++;
                }, 600);
                activeNodes.push({ stop: () => clearInterval(drumInterval) });
            }
            else if (type === 'battle_major') {
                // 1. Dark Cinema Drone (Filtered Saw with slow movement)
                const osc = audioCtx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = 35; // Deep cinematic bass

                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200; 

                // LFO to modulate filter brightness (Slow breathing effect)
                const lfo = audioCtx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 0.25; // Slow swell
                
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 150; // Open/Close filter range

                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);

                const gain = audioCtx.createGain();
                gain.gain.value = 0.2;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                osc.start(now);
                lfo.start(now);
                activeNodes.push(osc, filter, gain, lfo, lfoGain);

                // 2. Intense Cinematic Drums (Fast ~140 BPM)
                // 140 BPM = approx 428ms per beat
                let beat = 0;
                const drumInterval = setInterval(() => {
                    const t = audioCtx.currentTime;
                    // Cinematic Pattern: Kick - HiHat - Snare - HiHat
                    if (beat % 4 === 0) {
                        playDrum('kick', t);
                        playDrum('tom', t + 0.1); // Double kick feel
                    }
                    if (beat % 4 === 2) {
                        playDrum('snare', t); // Big impact snare
                        playDrum('kick', t); 
                    }
                    // Constant hi-hat drive
                    playDrum('hihat', t);
                    playDrum('hihat', t + 0.21); // 8th note

                    beat++;
                }, 428);
                activeNodes.push({ stop: () => clearInterval(drumInterval) });
            }
            else if (type === 'dungeon') {
                // 1. Uneasy Drone (Detuned Oscillators)
                const drone1 = audioCtx.createOscillator();
                drone1.type = 'triangle';
                drone1.frequency.value = 55; // Low A
                
                const drone2 = audioCtx.createOscillator();
                drone2.type = 'sine';
                drone2.frequency.value = 58; // Slightly higher for beating effect

                const droneGain = audioCtx.createGain();
                droneGain.gain.value = 0.15; // Low volume

                // Filter to darken the sound
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 300;

                drone1.connect(filter);
                drone2.connect(filter);
                filter.connect(droneGain);
                droneGain.connect(audioCtx.destination);
                
                drone1.start(now);
                drone2.start(now);
                activeNodes.push(drone1, drone2, droneGain);

                // 2. Echoing Water Drips (Random Panning)
                const dripInterval = setInterval(() => {
                    if (Math.random() > 0.6) {
                        const t = audioCtx.currentTime;
                        const osc = audioCtx.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(2000 + Math.random() * 500, t);
                        
                        const g = audioCtx.createGain();
                        g.gain.setValueAtTime(0, t);
                        g.gain.linearRampToValueAtTime(0.1, t + 0.01);
                        g.gain.exponentialRampToValueAtTime(0.001, t + 0.15); // Short blip

                        // Stereo Panner for spatial effect
                        const pan = audioCtx.createStereoPanner();
                        pan.pan.value = Math.random() * 2 - 1; // Left to Right

                        // Simple Delay line simulation (echo)
                        const delay = audioCtx.createDelay();
                        delay.delayTime.value = 0.3;
                        const delayGain = audioCtx.createGain();
                        delayGain.gain.value = 0.3;

                        osc.connect(g);
                        g.connect(pan);
                        pan.connect(audioCtx.destination);
                        
                        // Connect to delay for echo
                        g.connect(delay);
                        delay.connect(delayGain);
                        delayGain.connect(audioCtx.destination);
                        
                        osc.start(t);
                        osc.stop(t + 0.5);
                    }
                }, 3000);
                activeNodes.push({ stop: () => clearInterval(dripInterval) });

                // 3. Dark Ambient Music (E Phrygian Scale - Creepy/Ancient)
                const scale = [164.81, 174.61, 196.00, 220.00, 246.94, 261.63, 293.66]; // E, F, G, A, B, C, D
                
                const musicInterval = setInterval(() => {
                    const t = audioCtx.currentTime;
                    if (Math.random() > 0.4) {
                        const note = scale[Math.floor(Math.random() * scale.length)];
                        // Long attack/decay for "ghostly" pad sound
                        // Using triangle wave for a hollow sound
                        playNote(note, t, 3.5, 'triangle', 0.08);
                        
                        // Occasional deep bass note
                        if (Math.random() > 0.7) {
                             playNote(note / 2, t, 4, 'sine', 0.15);
                        }
                    }
                }, 4500); // Slow tempo
                activeNodes.push({ stop: () => clearInterval(musicInterval) });
            }
            else if (type === 'sleep') {
                // 1. Fire Rumble (Filtered Noise)
                const noise = audioCtx.createBufferSource();
                noise.buffer = noiseBuffer;
                noise.loop = true;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 120; // Deep warm roar
                const gain = audioCtx.createGain();
                gain.gain.value = 0.3;

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(now);
                activeNodes.push(noise, gain);

                // 2. Fire Crackles (Random high-freq bursts)
                const crackleInterval = setInterval(() => {
                    if (Math.random() > 0.7) {
                        const n = audioCtx.createBufferSource();
                        n.buffer = noiseBuffer;
                        const f = audioCtx.createBiquadFilter();
                        f.type = 'highpass';
                        f.frequency.value = 2000;
                        const g = audioCtx.createGain();
                        g.gain.value = 0.1 + Math.random() * 0.1;
                        g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                        n.connect(f);
                        f.connect(g);
                        g.connect(audioCtx.destination);
                        n.start();
                        n.stop(audioCtx.currentTime + 0.05);
                    }
                }, 200);
                activeNodes.push({ stop: () => clearInterval(crackleInterval) });

                // 3. Sleepy Music (Slow, dreamy sine waves)
                // G Major Pentatonic (Dreamy)
                const scale = [196.00, 220.00, 246.94, 293.66, 329.63]; // G3, A3, B3, D4, E4
                
                const sleepMusicInterval = setInterval(() => {
                    if (Math.random() > 0.4) {
                        const t = audioCtx.currentTime;
                        const noteIdx = Math.floor(Math.random() * scale.length);
                        // Long attack/decay for "ghostly" pad sound
                        playNote(scale[noteIdx], t, 4, 'sine', 0.1); 
                        
                        // Occasional gentle harmony
                        if (Math.random() > 0.5) {
                             playNote(scale[(noteIdx + 2) % scale.length], t + 0.5, 4, 'sine', 0.08); 
                        }
                    }
                }, 5000); // Very slow, every 5 seconds
                
                activeNodes.push({ stop: () => clearInterval(sleepMusicInterval) });
            }
        }

        // Login/Logout Functions (Requires Firebase Console Setup)
        window.loginWithGoogle = async function() {
            try {
                const provider = new GoogleAuthProvider();
                await signInWithPopup(window.auth, provider);
            } catch (error) {
                console.error("Login failed:", error);
                alert("Login failed. Check console for details. (Did you enable Google Auth in Firebase Console?)");
            }
        }

        window.logoutUser = async function() {
            try {
                await signOut(window.auth);
                window.location.reload(); // Reload to clear state
            } catch (error) {
                console.error("Logout failed:", error);
            }
        }

        function stopAmbience() {
            // Stop all sound nodes
            activeNodes.forEach(node => {
                if (node.stop) {
                    try { node.stop(); } catch(e) {}
                } else if (node.disconnect) {
                    node.disconnect();
                }
            });
            activeNodes = []; // Clear array

            // Reset UI
            document.querySelectorAll('.sound-btn').forEach(btn => btn.classList.remove('active-loop'));
            currentAmbience = null;
        }
        // --- NEW: Save API Key Logic ---
        window.saveApiKey = function() {
            const input = document.getElementById('user-api-key');
            const status = document.getElementById('api-key-status');
            const key = input.value.trim();
            
            if (key) {
                localStorage.setItem('dm_toolkit_api_key', key);
                userApiKey = key;
                status.textContent = "Status: Key saved!";
                status.className = "mt-2 text-xs text-green-400";
                input.value = ""; // Clear for security
            } else {
                status.textContent = "Status: Please enter a valid key.";
                status.className = "mt-2 text-xs text-red-400";
            }
        }

    </script>
</body>
</html>
